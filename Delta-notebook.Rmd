---
title: "Delta explorations"
output: html_notebook
---

Load the libraries
```{r}
library(nat)
library(neuprintr)
library(tidyverse)
library(tidygraph)
library(ggraph)
library(gridExtra)
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\pathways.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\R\\supertypeUtils.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\visualizeConnectivityTables.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\neuprintQueryUtils.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\colorCodeLookup.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\FBNetworkVisUtils.R")
options(nat.plotengine = 'rgl')
```

Connect to neuprint
```{r}
neuprint_login()
```


############################################################
FB columnar network diagrams
############################################################

Plot all FB columnar network connections - weight matrices
```{r}
nronTypes <- c("PFN","Delta0","Delta6","PFR_a","PFG","FC","PFL","^FR","FS","PFR_b")
ROI = "FB"
  
# Get the connection table
conTab <- getConnectionTable_forSubset(getBodyIdsForList(nronTypes)$bodyid,
                                         getBodyIdsForList(nronTypes)$bodyid,
                                         ROI)

# Generate a plot of the original connection table - columnar types only
conmatPlot <- plotConnectivityMatrix(conTab,byGroup="id")
conmatPlot <- addMatrixPlotLabs(conmatPlot, "pre-synaptic neurons", "post-synaptic neurons", "FB")
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\AllColumnarConnections_WM.pdf", width = 40, height = 40)
print(conmatPlot)
dev.off()


conTab_Clean <- cleanUpConTab(conTab)

# Generate a plot of the original connection table - columnar types only, cleaned up
conmatPlot_Clean <- plotConnectivityMatrix(conTab_Clean,byGroup="id")
conmatPlot_Clean <- addMatrixPlotLabs(conmatPlot_Clean, "pre-synaptic neurons", "post-synaptic neurons", "FB")
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\AllColumnarConnections_WM_Clean.pdf", width = 40, height = 40)
print(conmatPlot_Clean)
dev.off()

```

Plot all FB columnar network connections - graphs [All connections]
```{r}
textRepel = FALSE
guideOnOff = TRUE

xyLookup <- xyLookupTableInner()
gg_All <- graphConTab(conTab_Clean,xyLookup,textRepel,guideOnOff)
gg_All <- gg_All+ xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\AllColumnarConnections.pdf", width = 40, height = 40)
print(gg_All)
dev.off()

```

Plot all FB columnar network connections - graphs [Inputs]
```{r}
gg_Inputs <- list()
gg_Inputs[[1]] <- graphConTab(conTab_Clean[which(grepl("PFN",conTab_Clean$type.from)),],
                         xyLookup,FALSE,TRUE)
gg_Inputs[[1]] <- gg_Inputs[[1]] + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()

PFNTypes = getBodyIdsForList(c("PFN"))$type %>% unique() %>% sort()
for (pf in 1:length(PFNTypes)){
  gg_Inputs[[pf+1]] <- graphConTab(conTab_Clean[which(conTab_Clean$type.from == PFNTypes[pf]),],
                         xyLookup,TRUE,FALSE)
  gg_Inputs[[pf+1]] <- gg_Inputs[[pf+1]] + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()
}

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\AllColumnarConnections_Inputs.pdf", width = 60, height = 60)
print(grid.arrange(grobs = gg_Inputs,layout_matrix = rbind(c(1,3,9),c(2,4,5),c(6,7,8))))
dev.off()
```

Plot all FB columnar network connections - graphs [Outputs]
```{r}
gg_Outputs <- list()
gg_Outputs[[1]] <- graphConTab(filter(conTab_Clean, type.to %in% getBodyIdsForList(tail(nronTypes,4))$type),
                         xyLookup,FALSE,TRUE)
gg_Outputs[[1]] <- gg_Outputs[[1]] + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()

OutTypes = getBodyIdsForList(tail(nronTypes,4))$type %>% unique() %>% sort()
for (o in 1:length(OutTypes)){
  gg_Outputs[[o+1]] <- graphConTab(conTab_Clean[which(conTab_Clean$type.to == OutTypes[o]),], xyLookup,TRUE,FALSE)
  gg_Outputs[[o+1]] <- gg_Outputs[[o+1]] + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()
}

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\AllColumnarConnections_Outputs.pdf", width = 50, height = 60)
print(grid.arrange(grobs = gg_Outputs,layout_matrix = rbind(c(1,13,14,15),c(NA,16,2,3),c(NA,4,5,6),c(7,8,9,10),c(11,12,NA,NA))))
dev.off()
```

Plot all FB columnar network connections - graphs [Inner]
```{r}
gg_Inner <- list()
gg_Inner[[1]] <- graphConTab(filter(conTab_Clean, type.to %in% getBodyIdsForList(nronTypes[2:6])$type |
                                 type.from %in% getBodyIdsForList(nronTypes[2:6])$type),
                         xyLookup,FALSE,TRUE)
gg_Inner[[1]] <- gg_Inner[[1]] + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()

innerSuperTypes = c("Delta0","Delta6","FC","PFG","PFR_a")
for (i in 1:length(innerSuperTypes)){
  gg_Inner[[2*i]] <- graphConTab(conTab_Clean[which(grepl(innerSuperTypes[i],conTab_Clean$type.from)),],
                         xyLookup,TRUE,FALSE)
  gg_Inner[[2*i]] <- gg_Inner[[2*i]] + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()
  
  gg_Inner[[2*i+1]] <- graphConTab(conTab_Clean[which(grepl(innerSuperTypes[i],conTab_Clean$type.to)),],
                         xyLookup,TRUE,FALSE)
  gg_Inner[[2*i+1]] <- gg_Inner[[2*i+1]] + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()
}


pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\AllColumnarConnections_Inner.pdf", width = 60, height = 60)
print(grid.arrange(grobs = gg_Inner,layout_matrix = rbind(c(1,NA,2,3),c(4,5,6,7),c(8,9,10,11))))
dev.off()
```

Plot connections between inner FB super types
```{r}
innerTypes <- c("Delta0","Delta6","FC")
ROI = "FB"

gg_Inner <- list()
for (tp in 1:length(innerTypes)){
  # Get the connection table
  conTab <- getConnectionTable_forSubset(getBodyIdsForList(innerTypes[tp])$bodyid,
                                         getBodyIdsForList(innerTypes[tp])$bodyid,
                                         ROI)
  conTab_Clean <- cleanUpConTab(conTab)

  typesNow <- neuprint_search(paste0(innerTypes[tp],".*"))$type %>% unique() %>% sort()
  angs <- seq(-pi,pi,length.out=length(typesNow)+1)
  angs <- angs[1:(length(angs)-1)]
  xs <- 0.5*sin(angs)
  ys <- 0.5*cos(angs)
  xyLookup <- data.frame(type = typesNow, x = xs, y = ys)

  gg_Inner[[tp]] <- graphConTab(conTab_Clean,xyLookup,FALSE,FALSE)
  gg_Inner[[tp]] <- gg_Inner[[tp]] + xlim(-0.75,0.75) + ylim(-0.75,0.75) + scale_y_reverse()
}

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\AllColumnarConnections_Inner_BySubGroup.pdf", width = 60, height = 60)
print(grid.arrange(grobs = gg_Inner,nrow=1))
dev.off()

    

```

Plot the PFNa,FC1,Delta6B,PFL1 pathways
```{r}
pwayTypes <- c("PFNa","FC1","Delta6B","PFL1")
ROI <- "FB"

conTab <- getConnectionTable_forSubset(getBodyIdsForList(pwayTypes)$bodyid,
                                       getBodyIdsForList(pwayTypes)$bodyid,
                                       ROI)

conTab_Clean <- cleanUpConTab(conTab)

gg <- graphConTab(conTab_Clean,xyLookupTableInner(),FALSE,TRUE)
gg <- gg + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\PFNaToPFL1.pdf", width = 30, height = 30)
print(gg)
dev.off()

```

Plot the PFNd,v to Delta6B, Delta6B to others pathways
```{r}
tp1 = c("PFNd","PFNv")
tp2 = c("Delta6B")

ROI <- "FB"

conTab1 <- getConnectionTable_forSubset(getBodyIdsForList(tp1)$bodyid,
                                       getBodyIdsForList(tp2)$bodyid,
                                       ROI)
conTab1_Clean <- cleanUpConTab(conTab1)

conTab2 <- getConnectionTable(getBodyIdsForList(tp2)$bodyid,"POST",ROI,synThresh = 3)
conTab2 <- conTab2[which(!is.na(conTab2$type.to)),]
conTab2 <- conTab2[which(!grepl("FB",conTab2$type.to)),]
conTab2 <- conTab2[which(!grepl("EL",conTab2$type.to)),]
conTab2_Clean <- cleanUpConTab(conTab2)

conTab_Clean <- rbind(conTab1_Clean,conTab2_Clean)

gg <- graphConTab(conTab_Clean,xyLookupTableInner(),FALSE,TRUE)
gg <- gg + xlim(-0.75,0.75) + ylim(0.5,3.5) + scale_y_reverse()

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\PFNdvToDelta6B.pdf", width = 30, height = 30)
print(gg)
dev.off()
```

Look at the inputs to each columnar FB neuron supertype
```{r}
nronTypes <- c("PFN","Delta0","Delta6","PFR_a","PFG","FC","PFL","^FR","FS","PFR_b")
ROI = "FB"

# For each type, get all of the input and output partners
connsPre <- getConnectionTable(getBodyIdsForList(nronTypes)$bodyid,"PRE",ROI,synThresh = 3)
connsPre$superType.from <- connsPre$type.from %>% supertype()

# Find the total % of synapses coming from a given supertype
connsPre_Mean <- connsPre %>% group_by(type.to,superType.from) %>% summarize(weightByType = sum(ROIweight))

# Find the total number of synapses coming to a given type and normalize the superType synapses by these counts
totalWeight <- connsPre_Mean %>% group_by(type.to) %>% summarize(totalWeight = sum(weightByType))
connsPre_Mean$relativeWeight <- 0
for (tp in 1:nrow(totalWeight)){
  relWeightCalc <- connsPre_Mean[which(connsPre_Mean$type.to == totalWeight$type.to[tp]),] %>% mutate(relativeWeight = weightByType/totalWeight$totalWeight[tp])
  connsPre_Mean[which(connsPre_Mean$type.to == totalWeight$type.to[tp]),]$relativeWeight <- relWeightCalc$relativeWeight
}
g_Pre <- ggplot(connsPre_Mean) + geom_bar(aes(x=as.factor(type.to),weight=relativeWeight,fill=superType.from))

#As above, not for post synaptic connections
connsPost <- getConnectionTable(getBodyIdsForList(nronTypes)$bodyid,"POST",ROI,synThresh = 3)
connsPost$superType.to <- connsPost$type.to %>% supertype()
connsPost_Mean <- connsPost %>% group_by(type.from,superType.to) %>% summarize(weightByType = sum(ROIweight))
totalWeight <- connsPost_Mean %>% group_by(type.from) %>% summarize(totalWeight = sum(weightByType))
connsPost_Mean$relativeWeight <- 0
for (tp in 1:nrow(totalWeight)){
  relWeightCalc <- connsPost_Mean[which(connsPost_Mean$type.from == totalWeight$type.from[tp]),] %>% mutate(relativeWeight = weightByType/totalWeight$totalWeight[tp])
  connsPost_Mean[which(connsPost_Mean$type.from == totalWeight$type.from[tp]),]$relativeWeight <- relWeightCalc$relativeWeight
}
g_Post <- ggplot(connsPost_Mean) + geom_bar(aes(x=as.factor(type.from),weight=relativeWeight,fill=superType.to))

# Create bar plots for the percent of input and output coming from each supertype
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\RelativeInputsAndOutputs.pdf", width = 40, height = 10)
print(grid.arrange(g_Pre,g_Post,nrow=2))
dev.off()

```

Create a scatter plot for the percent input and output coming from each supertype
```{r}
# Merge pre and post into one data frame
connsFBt <- data.frame(type = filter(connsPre_Mean,superType.from == "FBt")$type.to, relativeWeightPre = filter(connsPre_Mean,superType.from == "FBt")$relativeWeight)
connsFBt <-  merge(connsFBt,
                   data.frame(type = filter(connsPost_Mean,superType.to == "FBt")$type.from, relativeWeightPost = filter(connsPost_Mean,superType.to == "FBt")$relativeWeight),by="type",all.x=TRUE, all.y = TRUE)
connsFBt[is.na(connsFBt)] <- 0
connsFBt$superType <- connsFBt$type %>% as.character() %>% supertype() %>% as.factor()

# Create data frame to plot lines between points
connsFBt_lines <- data.frame(x = c(), y = c(),type = c())
for (r in 1:nrow(connsFBt)){
  connsFBt_lines <- rbind(connsFBt_lines,
                          data.frame(x=as.factor("input"),
                                     y = connsFBt$relativeWeightPre[r],
                                     type = connsFBt$type[r]))
  connsFBt_lines <- rbind(connsFBt_lines,
                          data.frame(x=as.factor("output"),
                                     y = connsFBt$relativeWeightPost[r],
                                     type = connsFBt$type[r]))
}

g_FBt <- ggplot()
g_FBt <- g_FBt + geom_line(data=connsFBt_lines, aes(x=x,y=y,group=type),color='lightgray')
g_FBt <- g_FBt + geom_point(data=connsFBt,aes(x = as.factor("input"),y=relativeWeightPre,fill=superType),size=5,alpha=0.4,shape=25) +
  geom_point(data=connsFBt,aes(x = as.factor("output"),y=relativeWeightPost,fill=superType),size=5,alpha=0.4,shape=24)
g_FBt <- g_FBt + theme_classic() + scale_y_continuous(limits = c(0,1), expand = c(0, 0)) +
  xlab("synapses on FB columnar neurons") + ylab("% of synapses from FB tangential cells") +
  guides(color=guide_legend(ncol=1))

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\RelativeInputsAndOutputs_Scatter.pdf", width = 8, height = 8)
print(g_FBt)
dev.off()
```

Create a scatter plot for the total number of FBt cells synapsing onto each columnar type
```{r}
# Find the total # of type to type connections (NOT weights) from one type to a superType
connsPre_NronCounts <- connsPre %>% group_by(type.to,to,superType.from) %>% summarize(totalNrons = length(from)) %>%
  group_by(type.to,superType.from) %>% summarize(meanCxns = mean(totalNrons))

connsPost_NronCounts <- connsPost %>% group_by(type.from,from,superType.to) %>% summarize(totalNrons = length(to)) %>%
  group_by(type.from,superType.to) %>% summarize(meanCxns = mean(totalNrons))


# Create a bar plot for the total number of FB tangentials synapsing onto each type
connsFBt <- data.frame(type = filter(connsPre_NronCounts,superType.from == "FBt")$type.to,
                       meanCxnsPre = filter(connsPre_NronCounts,superType.from == "FBt")$meanCxns)
connsFBt <-  merge(connsFBt,
                   data.frame(type = filter(connsPost_NronCounts,superType.to == "FBt")$type.from,
                       meanCxnsPost = filter(connsPost_NronCounts,superType.to == "FBt")$meanCxns),by="type",all.x=TRUE, all.y = TRUE)
connsFBt[is.na(connsFBt)] <- 0
connsFBt$superType <- connsFBt$type %>% as.character() %>% supertype() %>% as.factor()

# Create data frame to plot lines between points
connsFBt_lines <- data.frame(x = c(), y = c(),type = c())
for (r in 1:nrow(connsFBt)){
  connsFBt_lines <- rbind(connsFBt_lines,
                          data.frame(x=as.factor("input"),
                                     y = connsFBt$meanCxnsPre[r],
                                     type = connsFBt$type[r]))
  connsFBt_lines <- rbind(connsFBt_lines,
                          data.frame(x=as.factor("output"),
                                     y = connsFBt$meanCxnsPost[r],
                                     type = connsFBt$type[r]))
}

g_FBt <- ggplot()
g_FBt <- g_FBt + geom_line(data=connsFBt_lines, aes(x=x,y=y,group=type),color='lightgray')
g_FBt <- g_FBt + geom_point(data=connsFBt,aes(x = as.factor("input"),y=meanCxnsPre,fill=superType),size=5,alpha=0.4,shape=25) +
  geom_point(data=connsFBt,aes(x = as.factor("output"),y=meanCxnsPost,fill=superType),size=5,alpha=0.4,shape=24)
g_FBt <- g_FBt + theme_classic() + scale_y_continuous(limits = c(0,150), expand = c(0, 0)) +
  xlab("synapses on FB columnar neurons") + ylab("mean number of connected FB columnar neurons") +
  guides(color=guide_legend(ncol=2))

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\RelativeInputsAndOutputs_Scatter_Counts.pdf", width = 8, height = 8)
print(g_FBt)
dev.off()

```

############################################################
Delta 12 Analyses
############################################################

Check the clustering for all the neurons of a given type
```{r}
D0types <- neuprint_search("Delta0.*",field="type")$type %>% unique()
D0types <- D0types[which(!is.na(D0types))]

numClusts = 4

g_list <- list()
for (tp in 1:length(D0types)){
  
  # Get the D0 and D12 bodyids for a given neuron type
  bodyids <- neuprint_search(paste0(D0types[tp],".*"),field="type")$bodyid
  
  # Cluster their synapses into the appropraite quadrant
  synDat <- DeltaSynClust(bodyids, numClusts)
  
  # Plot the clusters
  g_list[[tp]] <- ggplot(synDat) + geom_point(aes(x=x,y=z,color=quad)) + theme_classic() + scale_y_reverse() + ggtitle(D0types[tp]) + coord_equal(ratio=1)
}

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta0Clustering.pdf", width = 40, height = 40)
print(grid.arrange(grobs = g_list))
dev.off()
```

Plot an example Delta 0 connection matrix, grouping Delta 12s and Delta 0s by type
```{r}
exType = 5
synThresh = 3

numClusts = 4
quads <- c("DL","DR","UL","UR")

# Get the D0 and D12 bodyids for the chosen type
bodyids <- neuprint_search(paste0(D0types[exType],".*"),field="type")$bodyid
  
  
# Cluster their synapses into the appropraite quadrant
synDat <- DeltaSynClust(bodyids, numClusts)
  
# Pull out the D12 neurons from the D0 population
D12bodyids <- c()
for (bid in 1:length(bodyids)){
  xs = synDat %>% filter(bodyid == bodyids[bid]) %>% select(x)
  if ((max(xs)-min(xs)) > (0.75*(max(synDat$x)-min(synDat$x))))
    D12bodyids <- append(D12bodyids,bodyids[bid])
}
    
# Find the mean number of input connections per type per quadrant
DeltaInputs <-  synDat %>% filter(prepost == TRUE) %>%
  group_by(bodyid,quad,partner) %>% summarize(weight = length(partner)) %>% 
  mutate(type.to = neuprint_get_meta(bodyid)$type,
         type.from = neuprint_get_meta(partner)$type,
         name.to = neuprint_get_meta(bodyid)$name,
         name.from = neuprint_get_meta(partner)$name)
DeltaInputs[which(DeltaInputs$bodyid %in% D12bodyids),]$type.to <- gsub("0","12",D0types[exType])
DeltaInputs[which(DeltaInputs$bodyid %in% D12bodyids),]$name.to <- gsub("0","12",D0types[exType])
names(DeltaInputs)[names(DeltaInputs) == 'bodyid'] <- 'to'
names(DeltaInputs)[names(DeltaInputs) == 'partner'] <- 'from'
DeltaInputs$nameid.from = paste(as.character(DeltaInputs$name.from), as.character(DeltaInputs$from), sep = "_")
DeltaInputs$nameid.to = paste(as.character(DeltaInputs$name.to), as.character(DeltaInputs$to), sep = "_")
DeltaInputs_Mean <- DeltaInputs %>% group_by(type.to,quad,type.from) %>% summarize(weightMean = mean(weight))
DeltaInputs_Mean$nameid.to.quad <- paste(as.character(DeltaInputs_Mean$quad), as.character(DeltaInputs_Mean$type.to), sep = "-") %>% as.factor()
DeltaInputs_Mean <- DeltaInputs_Mean %>% filter(weightMean > synThresh)

# Plot the correlation matrix between inputs
conmatPlot_inputs = ggplot(DeltaInputs_Mean) + 
    theme_classic() + theme(axis.text.x = element_text(angle = 90)) +
    scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                         midpoint =0.5*max(DeltaInputs_Mean$weightMean), limits=c(0,max(DeltaInputs_Mean$weightMean)))
conmatPlot_inputs = conmatPlot_inputs + geom_tile(aes(nameid.to.quad,type.from,fill=weightMean)) + ggtitle(D0types[exType])
conmatPlot_inputs = conmatPlot_inputs + xlab("Post-synaptic neuron")+ylab("Pre-synaptic neuron")

# Find the mean number of output connections per type per quadrant
DeltaOutputs <-  synDat %>% filter(prepost == FALSE) %>%
  group_by(bodyid,quad,partner) %>% summarize(weight = length(partner)) %>% 
  mutate(type.from = neuprint_get_meta(bodyid)$type,
         type.to = neuprint_get_meta(partner)$type,
         name.from = neuprint_get_meta(bodyid)$name,
         name.to = neuprint_get_meta(partner)$name)
DeltaOutputs[which(DeltaOutputs$bodyid %in% D12bodyids),]$type.from <- gsub("0","12",D0types[exType])
DeltaOutputs[which(DeltaOutputs$bodyid %in% D12bodyids),]$name.from <- gsub("0","12",D0types[exType])
names(DeltaOutputs)[names(DeltaOutputs) == 'bodyid'] <- 'from'
names(DeltaOutputs)[names(DeltaOutputs) == 'partner'] <- 'to'
DeltaOutputs$nameid.from = paste(as.character(DeltaOutputs$name.from), as.character(DeltaOutputs$from), sep = "_")
DeltaOutputs$nameid.to = paste(as.character(DeltaOutputs$name.to), as.character(DeltaOutputs$to), sep = "_")
DeltaOutputs_Mean <- DeltaOutputs %>% group_by(type.from,quad,type.to) %>% summarize(weightMean = mean(weight))
DeltaOutputs_Mean$nameid.from.quad <- paste(as.character(DeltaOutputs_Mean$quad), as.character(DeltaOutputs_Mean$type.from), sep = "-") %>% as.factor()
DeltaOutputs_Mean <- DeltaOutputs_Mean %>% filter(weightMean > synThresh)

# Plot the correlation matrix between inputs
conmatPlot_outputs = ggplot(DeltaOutputs_Mean) + 
    theme_classic() + theme(axis.text.x = element_text(angle = 90)) +
    scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                         midpoint =0.5*max(DeltaOutputs_Mean$weightMean), limits=c(0,max(DeltaOutputs_Mean$weightMean)))
conmatPlot_outputs = conmatPlot_outputs + geom_tile(aes(type.to,nameid.from.quad,fill=weightMean)) + ggtitle(D0types[exType])
conmatPlot_outputs = conmatPlot_outputs + xlab("Post-synaptic neuron")+ylab("Pre-synaptic neuron")

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta0And12Example_WMs_ByType.pdf", width = 40, height = 40)
print(grid.arrange(conmatPlot_inputs,conmatPlot_outputs))
dev.off()

```

Cluster synapses, pull out the D12 bodyids, separate inputs and outputs, and plot the correlation matrix across inputs or outputs across type
```{r}
D0types <- neuprint_search("Delta0.*",field="type")$type %>% unique()
D0types <- D0types[which(!is.na(D0types))]

numClusts = 4
quads <- c("DL","DR","UL","UR")

cormatPlot_inputs_all <- list()
cormatPlot_outputs_all <- list()
for (tp in 1:length(D0types)){
  
  # Get the D0 and D12 bodyids for a given neuron type
  bodyids <- neuprint_search(paste0(D0types[tp],".*"),field="type")$bodyid
  
  
  # Cluster their synapses into the appropraite quadrant
  synDat <- DeltaSynClust(bodyids, numClusts)
  
  # Pull out the D12 neurons from the D0 population
  D12bodyids <- c()
  for (bid in 1:length(bodyids)){
    xs = synDat %>% filter(bodyid == bodyids[bid]) %>% select(x)
    if ((max(xs)-min(xs)) > (0.75*(max(synDat$x)-min(synDat$x))))
      D12bodyids <- append(D12bodyids,bodyids[bid])
  }
      
  # Find the mean number of input connections per type per quadrant
  DeltaInputs <-  synDat %>% filter(prepost == TRUE) %>%
    group_by(bodyid,quad,partner) %>% summarize(weight = length(partner)) %>% 
    mutate(type.to = neuprint_get_meta(bodyid)$type,
           type.from = neuprint_get_meta(partner)$type,
           name.to = neuprint_get_meta(bodyid)$name,
           name.from = neuprint_get_meta(partner)$name)
  if (length(D12bodyids) > 0) {
    DeltaInputs[which(DeltaInputs$bodyid %in% D12bodyids),]$type.to <- gsub("0","12",D0types[tp])
    DeltaInputs[which(DeltaInputs$bodyid %in% D12bodyids),]$name.to <- gsub("0","12",D0types[tp])
  }
  names(DeltaInputs)[names(DeltaInputs) == 'bodyid'] <- 'to'
  names(DeltaInputs)[names(DeltaInputs) == 'partner'] <- 'from'
  DeltaInputs$nameid.from = paste(as.character(DeltaInputs$name.from), as.character(DeltaInputs$from), sep = "_")
  DeltaInputs$nameid.to = paste(as.character(DeltaInputs$name.to), as.character(DeltaInputs$to), sep = "_")
  DeltaInputs_Mean <- DeltaInputs %>% group_by(nameid.to,quad,type.from) %>% summarize(weightMean = mean(weight))
  DeltaInputs_Mean$nameid.to.quad <- paste(as.character(DeltaInputs_Mean$quad), as.character(DeltaInputs_Mean$nameid.to), sep = "-") %>% as.factor()
  
  # Plot the correlation matrix between inputs
  cormatPlot_inputs <- corMatPlot(DeltaInputs_Mean,"type.from","nameid.to.quad")
  offset  <- 0.5
  for (l in 1:4){
    offset <-  offset + length(which(grepl(paste0(quads[l],"-Delta0"),unique(as.character(DeltaInputs_Mean$nameid.to.quad)))))
    cormatPlot_inputs <- cormatPlot_inputs + geom_vline(xintercept = offset)
    cormatPlot_inputs <- cormatPlot_inputs + geom_hline(yintercept = offset)
    
    offset <-  offset + length(which(grepl(paste0(quads[l],"-Delta12"),unique(as.character(DeltaInputs_Mean$nameid.to.quad)))))
    cormatPlot_inputs <- cormatPlot_inputs + geom_vline(xintercept = offset)
    cormatPlot_inputs <- cormatPlot_inputs + geom_hline(yintercept = offset)
  }
  cormatPlot_inputs_all[[tp]] <- cormatPlot_inputs
  
  # Find the mean number of output connections per type per quadrant
  DeltaOutputs <-  synDat %>% filter(prepost == FALSE) %>%
    group_by(bodyid,quad,partner) %>% summarize(weight = length(partner)) %>% 
    mutate(type.from = neuprint_get_meta(bodyid)$type,
           type.to = neuprint_get_meta(partner)$type,
           name.from = neuprint_get_meta(bodyid)$name,
           name.to = neuprint_get_meta(partner)$name)
  if (length(D12bodyids) > 0) {
    DeltaOutputs[which(DeltaOutputs$bodyid %in% D12bodyids),]$type.from <- gsub("0","12",D0types[tp])
    DeltaOutputs[which(DeltaOutputs$bodyid %in% D12bodyids),]$name.from <- gsub("0","12",D0types[tp])
  }
  names(DeltaOutputs)[names(DeltaOutputs) == 'bodyid'] <- 'from'
  names(DeltaOutputs)[names(DeltaOutputs) == 'partner'] <- 'to'
  DeltaOutputs$nameid.from = paste(as.character(DeltaOutputs$name.from), as.character(DeltaOutputs$from), sep = "_")
  DeltaOutputs$nameid.to = paste(as.character(DeltaOutputs$name.to), as.character(DeltaOutputs$to), sep = "_")
  DeltaOutputs_Mean <- DeltaOutputs %>% group_by(nameid.from,quad,type.to) %>% summarize(weightMean = mean(weight))
  DeltaOutputs_Mean$nameid.from.quad <- paste(as.character(DeltaOutputs_Mean$quad), as.character(DeltaOutputs_Mean$nameid.from), sep = "-") %>% as.factor()
  
  # Plot the correlation matrix between inputs
  cormatPlot_outputs <- corMatPlot(DeltaOutputs_Mean,"type.to","nameid.from.quad")
  offset  <- 0.5
  for (l in 1:4){
    offset <-  offset + length(which(grepl(paste0(quads[l],"-Delta0"),unique(as.character(DeltaOutputs_Mean$nameid.from.quad)))))
    cormatPlot_outputs <- cormatPlot_outputs + geom_vline(xintercept = offset)
    cormatPlot_outputs <- cormatPlot_outputs + geom_hline(yintercept = offset)
    
    offset <-  offset + length(which(grepl(paste0(quads[l],"-Delta12"),unique(as.character(DeltaOutputs_Mean$nameid.from.quad)))))
    cormatPlot_outputs <- cormatPlot_outputs + geom_vline(xintercept = offset)
    cormatPlot_outputs <- cormatPlot_outputs + geom_hline(yintercept = offset)
  }
  cormatPlot_outputs_all[[tp]] <- cormatPlot_outputs
  
}

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta0And12InputsByType_CorrelationMatrix.pdf", width = 40, height = 40)
print(grid.arrange(grobs = cormatPlot_inputs_all))
dev.off()

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta0And12OutputsByType_CorrelationMatrix.pdf.pdf", width = 40, height = 40)
print(grid.arrange(grobs = cormatPlot_outputs_all))
dev.off()
```

Calculate a metric to quantify differences in correlation matrix numbers by quadrant and by Delta 0 or by Delta 12
- mean and sd of corr coef
  - within type and quadrant (minus to self)
  - within U or D
    - to self type
    - across type
    ```{r}
D0types <- neuprint_search("Delta0.*",field="type")$type %>% unique()
D0types <- D0types[which(!is.na(D0types))]

numClusts = 4
quads <- c("DL","DR","UL","UR")

cormatMetrics_inputs <- ggplot()
cormatMetrics_outputs <- ggplot()
for (tp in 1:length(D0types)){
  
  # Get the D0 and D12 bodyids for a given neuron type
  bodyids <- neuprint_search(paste0(D0types[tp],".*"),field="type")$bodyid
  
  
  # Cluster their synapses into the appropraite quadrant
  synDat <- DeltaSynClust(bodyids, numClusts)
  
  # Pull out the D12 neurons from the D0 population
  D12bodyids <- c()
  for (bid in 1:length(bodyids)){
    xs = synDat %>% filter(bodyid == bodyids[bid]) %>% select(x)
    if ((max(xs)-min(xs)) > (0.75*(max(synDat$x)-min(synDat$x))))
      D12bodyids <- append(D12bodyids,bodyids[bid])
  }
      
  # Find the mean number of input connections per type per quadrant
  DeltaInputs <-  synDat %>% filter(prepost == TRUE) %>%
    group_by(bodyid,quad,partner) %>% summarize(weight = length(partner)) %>% 
    mutate(type.to = neuprint_get_meta(bodyid)$type,
           type.from = neuprint_get_meta(partner)$type,
           name.to = neuprint_get_meta(bodyid)$name,
           name.from = neuprint_get_meta(partner)$name)
  if (length(D12bodyids) > 0) {
    DeltaInputs[which(DeltaInputs$bodyid %in% D12bodyids),]$type.to <- gsub("0","12",D0types[tp])
    DeltaInputs[which(DeltaInputs$bodyid %in% D12bodyids),]$name.to <- gsub("0","12",D0types[tp])
  }
  names(DeltaInputs)[names(DeltaInputs) == 'bodyid'] <- 'to'
  names(DeltaInputs)[names(DeltaInputs) == 'partner'] <- 'from'
  DeltaInputs$nameid.from = paste(as.character(DeltaInputs$name.from), as.character(DeltaInputs$from), sep = "_")
  DeltaInputs$nameid.to = paste(as.character(DeltaInputs$name.to), as.character(DeltaInputs$to), sep = "_")
  DeltaInputs_Mean <- DeltaInputs %>% group_by(nameid.to,quad,type.from) %>% summarize(weightMean = mean(weight))
  DeltaInputs_Mean$nameid.to.quad <- paste(as.character(DeltaInputs_Mean$quad), as.character(DeltaInputs_Mean$nameid.to), sep = "-") %>% as.factor()
  
  # Plot the correlation matrix between inputs

  
  # Find the mean number of output connections per type per quadrant
  DeltaOutputs <-  synDat %>% filter(prepost == FALSE) %>%
    group_by(bodyid,quad,partner) %>% summarize(weight = length(partner)) %>% 
    mutate(type.from = neuprint_get_meta(bodyid)$type,
           type.to = neuprint_get_meta(partner)$type,
           name.from = neuprint_get_meta(bodyid)$name,
           name.to = neuprint_get_meta(partner)$name)
  if (length(D12bodyids) > 0) {
    DeltaOutputs[which(DeltaOutputs$bodyid %in% D12bodyids),]$type.from <- gsub("0","12",D0types[tp])
    DeltaOutputs[which(DeltaOutputs$bodyid %in% D12bodyids),]$name.from <- gsub("0","12",D0types[tp])
  }
  names(DeltaOutputs)[names(DeltaOutputs) == 'bodyid'] <- 'from'
  names(DeltaOutputs)[names(DeltaOutputs) == 'partner'] <- 'to'
  DeltaOutputs$nameid.from = paste(as.character(DeltaOutputs$name.from), as.character(DeltaOutputs$from), sep = "_")
  DeltaOutputs$nameid.to = paste(as.character(DeltaOutputs$name.to), as.character(DeltaOutputs$to), sep = "_")
  DeltaOutputs_Mean <- DeltaOutputs %>% group_by(nameid.from,quad,type.to) %>% summarize(weightMean = mean(weight))
  DeltaOutputs_Mean$nameid.from.quad <- paste(as.character(DeltaOutputs_Mean$quad), as.character(DeltaOutputs_Mean$nameid.from), sep = "-") %>% as.factor()
  
  # Plot the correlation matrix between inputs
  cormat_outputs <- corMat(DeltaOutputs_Mean,"type.to","nameid.from.quad")
  
}

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta0And12InputsByType_CorrelationMatrix.pdf", width = 40, height = 40)
print(grid.arrange(grobs = cormatPlot_inputs_all))
dev.off()

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta0And12OutputsByType_CorrelationMatrix.pdf.pdf", width = 40, height = 40)
print(grid.arrange(grobs = cormatPlot_outputs_all))
dev.off()
```

############################################################
Old Plots
############################################################

Plot the connection of a given PFN type to its downstream partners
```{r}
# Get the PFN types (which will specify the inputs) and specify the end types (outputs)
PFNTypes <- neuprint_search("PFN.*")$type %>% unique()

# Specify the output types
outTypes <- c("PFL","^FR","FS","PFR_b","FC1_b")

# Choose how many layers (between start and end) to step through in the network
stopLayer = 3
ROI = "FB"
synThresh = 4

xyLookup <- xyLookupTableCol()

gg_list = list()
# Generate a graph for each PFN type
for (pf in 1:length(PFNTypes)){
  
  # Get the starting PFN type
  seedInput = PFNTypes[pf]
  
  # Get the connection table
  # Find the columnar downstream partners of the PFN class in the FB
  conTab1 <- getConnectionTable(getBodyIdsForList(PFNTypes[pf])$bodyid,"POST",ROI,synThresh = synThresh)
  conTab1 <- conTab1[which(!is.na(conTab1$type.to) & !is.na(conTab1$type.from)),]
  conTab1 <- conTab1[which(!grepl("FB",conTab1$type.to)),]
  conTab1 <- cleanUpConTab(conTab1)
  
  # Find the subset of the above connections which go to the FB outputs 
  conTab1_Out <- conTab1 %>% filter(type.to %in% unique(getBodyIdsForList(outTypes)$type))
  conTab1_Self <- conTab1 %>% filter(grepl(seedInput,type.to))
  conTab1_Other <- conTab1 %>% filter(!grepl(seedInput,type.to))
  conTab1_Other <- conTab1_Other %>% filter(!(type.to %in% unique(getBodyIdsForList(outTypes)$type)))
  
  # Find the columnar downstream partners of the PFN columnar outputs
  conTab2 <- getConnectionTable(getBodyIdsForList(unique(conTab1_Other$type.to))$bodyid,"POST",ROI,synThresh = synThresh)
  conTab2 <- conTab2[which(!is.na(conTab2$type.to) & !is.na(conTab2$type.from)),]
  conTab2 <- conTab2[which(!grepl("FB",conTab2$type.to)),]
  conTab2 <- cleanUpConTab(conTab2)
  
  # Find the subset of the above connections which go to the FB outputs
  conTab2_Out <- conTab2 %>% filter(type.to %in% unique(getBodyIdsForList(outTypes)$type))
  conTab1_Inter <- conTab1_Other %>% filter(type.to %in% unique(conTab2_Out$type.from))
  conTab1_Other <- conTab1_Other %>% filter(!(type.to %in% unique(conTab2_Out$type.from)))
  
  # Find connections between interneurons
  conTab2_Inter <- getConnectionTable_forSubset(getBodyIdsForList(unique(conTab2_Out$type.from))$bodyid,
                                                getBodyIdsForList(unique(conTab2_Out$type.from))$bodyid,
                                                ROI,synThresh = synThresh)
  conTab2_Inter <- cleanUpConTab(conTab2_Inter)
  
  # Combine them all into one connectivity matrix
  conTab <- rbind(conTab1_Out,conTab1_Self,conTab1_Inter,conTab2_Out,conTab2_Inter,conTab1_Other)
  
  # Plot the network
  gg <- graphConTab(conTab,xyLookup)
  gg <- gg + xlim(-3.5,3.5) + ylim(0.5,3.5) + scale_y_reverse()
  
  # Generate a plot of the original connection table - columnar types only
  conmatPlot <- plotConnectivityMatrix(conTab)
  conmatPlot <- structureMatrixPlotByType(conmatPlot)
  conmatPlot <- addMatrixPlotLabs(conmatPlot, "pre-synaptic neurons", "post-synaptic neurons", "FB")
  conmatPlot <- conmatPlot + theme(strip.text.x = element_text(size = 36),strip.text.y = element_text(size = 36,angle = 270))
  
  # Generate an output pdf of the plots
  pdf(paste0("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\DeltaNetworkLinear_",seedInput,".pdf"), width = 30, height = 30)
  print(grid.arrange(gg,conmatPlot,nrow = 2))
  dev.off()

  # Add the network diagram to a list to plot at the end
  gg_list[[pf]] <- gg
}

# Plot the overall network layout
xyLookup$superType <- xyLookup$type %>% as.character() %>% supertype()
sTs <- xyLookup$type %>% as.character() %>% supertype() %>% unique() %>% sort() %>% as.factor()
sTScale <- scale_colour_discrete(drop=TRUE,limits = levels(sTs))
ggRef <- ggplot(xyLookup,aes(x=x,y=y)) + geom_point(aes(color=superType),size=15) + scale_y_reverse() + geom_text(aes(label=type),hjust=0, vjust=0,size=12,angle=40)+
        theme_classic() +
  theme(legend.text=element_text(size=36),legend.title=element_text(size=36),
        axis.line=element_blank(),axis.text.x=element_blank(),
        axis.text.y=element_blank(),axis.ticks=element_blank()) + 
  coord_fixed(ratio = 1)
  sTScale
gg_list[[pf+1]] <- ggRef
gg_list <- c(tail(gg_list,1),head(gg_list,pf))

pltOrder <- c(1,1,3,9,2,4,5,6,7,8)
gg_list_to_plot <- list()
for (p in 1:length(pltOrder)){
  gg_list_to_plot[[p]] <- gg_list[[pltOrder[p]]]
}
  
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\DeltaNetworkLinear_All.pdf", width = 40, height = 40)
print(
  do.call("grid.arrange",
          c(gg_list_to_plot,
          ncol=2)))
dev.off()

```


Plot the FB tangential connections
```{r}
# Load libraries for plotting
library(tidygraph)
library(ggraph)
library(gridExtra)

# Specify the types to compare
preTypes <- c("FB")
postTypes <- c("PFN","Delta0","SAF","Delta6","PFR","PFG","PFL","FC","^FR","FS")

# Set the ROI and the synapse threshold
ROI = "FB"
synThresh = 4

# Generate the graphs
gg_list = list()
# Generate a graph for each PFN type
for (pt in 1:length(postTypes)){
  
  # Get the connection table
  conTab <- getConnectionTable_forSubset(getBodyIdsForList(append(preTypes,postTypes[pt]))$bodyid,
                                         getBodyIdsForList(append(preTypes,postTypes[pt]))$bodyid,
                                         ROI)
  conTab <- conTab[which(!is.na(conTab$type.from) & !is.na(conTab$type.to)), ]
  conTab <- conTab[which(!grepl(preTypes[1],conTab$type.from) | !grepl(preTypes[1],conTab$type.to)), ]
  conTab <- conTab[which(!grepl(postTypes[pt],conTab$type.from) | !grepl(postTypes[pt],conTab$type.to)), ]
  
  # Get the table of nodes (types)
  nodes = data.frame(name = unique(c(conTab$type.from,conTab$type.to)))
  nodes$superType <- nodes$name %>% as.character %>% supertype()
  
  # Position the nodes according to the lookup table
  xyLookup <- xyLookupTableTan()
  nodes$x <- sapply(nodes$name, function(x) xyLookup$x[match(x,xyLookup$type)])
  nodes$y <- sapply(nodes$name, function(x) xyLookup$y[match(x,xyLookup$type)])
  
  # Get the edges from the connection table
  edges <- conTab %>%
    mutate(to = sapply(type.to, function(f) which(f == nodes$name)),
           from = sapply(type.from, function(f) which(f == nodes$name)))
  
  # Get the mean weights between types in the connection table
  edges_Mean <- unique(edges[,c('from','to')])
  meanWs <- c()
  for (i in 1:nrow(edges_Mean)){
    meanWs <- append(meanWs,
                     mean(edges[which((edges$from == edges_Mean$from[i]) & (edges$to == edges_Mean$to[i])),]$weightRelative))
  }
  edges_Mean$weightRelative <- meanWs
  
  # Plot the network
  graph <- tbl_graph(nodes,edges_Mean)
  
  # Generate an output pdf of the plots
  pdf(paste0("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\FBTangNetwork_",postTypes[pt],".pdf"), width = 50, height = 50)
  gg <-
    ggraph(graph,layout="manual",x=nodes$x,y=nodes$y) + 
        geom_edge_fan(aes(width=weightRelative),colour="grey",alpha=0.5,
                      strength=1,
                      arrow = arrow(length = unit(2, "cm")),
                      end_cap = circle(2, 'cm')) + 
        geom_edge_loop(colour="grey",aes(direction=10,span=10,width=weightRelative),alpha=0.5) +
        geom_node_point(aes(color=superType),size=5) + 
        geom_node_text(aes(label=name),angle=40,size=6) +
        scale_y_reverse() + theme_classic() + theme(legend.text=element_text(size=36)) +
    theme(legend.text=element_text(size=36),legend.title=element_text(size=36),
          axis.line=element_blank(),axis.text.x=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank()) + 
    coord_fixed(ratio = 1) 
  
  
  print(gg)
  dev.off()

  gg_list[[pt]] <- gg
}

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\NetworkDiagrams\\FBTangNetwork_All.pdf", width = 50, height = 100)
print(
  do.call("grid.arrange",
          c(gg_list,
          ncol=2)))
dev.off()

```


Plot graph of Delta<->Delta connections
```{r}
preNeuron = c("Delta")
postNeuron = c("Delta")
slctROI = "FB"

# Get connectivity table
preIDs = getBodyIdsForList(preNeuron)
postIDs = getBodyIdsForList(postNeuron)
myConnections = getConnectionTable_forSubset(preIDs$bodyid,postIDs$bodyid, slctROI)

require(igraph)
# Reroganize to make graph with types instead of bodyids
graphData = data.frame(from = myConnections$type.from, to = myConnections$type.to, weight = myConnections$ROIweight)
graphData = graphData %>% group_by(from, to) %>% summarise(weight = mean(weight, na.rm = TRUE)) %>% ungroup()

# Cutoff low synapse counts (and compare connections before and after)
hist(graphData$weight, n=100)
cutoff = 2
graphData = graphData %>% filter(weight > cutoff)
hist(graphData$weight, n=100)

# Separate connections within a type and across types
graphData_noSelf = graphData %>% filter(as.character(from) != as.character(to))
graphData_toSelf = graphData %>% filter(as.character(from) == as.character(to))

# Pull out the nodes of the graph
nodes  = union(unique(graphData_noSelf$from), unique(graphData_noSelf$to))

# Process self connections (will serve as size of circles in plot)
graphData_selfFB = full_join(data.frame("from" = graphData_toSelf$from, "weight" = graphData_toSelf$weight), data.frame("from" = nodes))
graphData_selfFB$weight[is.na(graphData_selfFB$weight)] <- 0

# Create a graph object from the connections across types
connectGraph = graph_from_data_frame(graphData_noSelf)
connectGraph <- delete_edges(connectGraph, E(connectGraph)[weight<cutoff])
connectGraph

# Assign colors to the nodes from the lookup table
nodeCols = seq(1, length(nodes))
for (i in seq(1, length(nodes))) {
  nodeCols[i] = colors()[colorValueLookup$col[colorValueLookup$type == nodes[i]]]
}

# Make labels for the nodes in the graph
V(connectGraph)$label.color="black"
V(connectGraph)$label.cex=0.8
V(connectGraph)$label.dist=0

# Make the size of each node correspond to the number of self connections
V(connectGraph)$size = 7 + as.numeric(7*graphData_selfFB$weight/max(c(1, max(graphData_selfFB$weight) ) ) )
V(connectGraph)$vertex.frame.color="gray"
V(connectGraph)$color=nodeCols

# Set edge width based on weight:
E(connectGraph)$width <- E(connectGraph)$weight/5.
#change arrow size and edge color:
E(connectGraph)$arrow.size <- 1
#E(connectGraph)$edge.color <- "gray80"
edge.start <- ends(connectGraph, es=E(connectGraph), names=F)[,1]
edge.col = V(connectGraph)$color[edge.start]

l <- layout_with_fr(connectGraph) # layout_components

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\DeltaNetwork.pdf", width = 10, height = 10)#, units ="cm", dpi = 600)
plot(connectGraph,edge.color=edge.col, edge.curved=0.5, layout=l)  #vertex.shape="fcircle", 

```

Look at Delta6B inputs
```{r}
D6B_Pre <- getConnectionTable(getBodyIdsForList(c("Delta6B")),"PRE","FB")
D6B_Pre <- 
p <- connectivityBarPlot(D6B_Pre,"PRE") + ggtitle("Delta6B inputs")
print(p)
ggsave("Delta6BInputs.pdf", plot = last_plot(), device='pdf', 
       path = "C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\",
       scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
```

Find the shortest path between a given input and output neuron
```{r}
inNrons1 = inputTypes[17] %>% paste(".*",sep="") %>% neuprint_search()
outNrons1 = outputTypes[19] %>% paste(".*",sep="") %>% neuprint_search()

# Don't forget the min weight!!!
queryNow = "MATCH (a:`hemibrain_Neuron`{bodyId:" %>% paste0(inNrons1$bodyid[1]) %>% paste0("}), (b:`hemibrain_Neuron`{bodyId:") %>% paste0(outNrons1$bodyid[1]) %>% paste0("}), p = allShortestPaths((a)-[:ConnectsTo*]->(b)) WHERE ALL (x in relationships(p) WHERE x.weight >= 5 AND EXISTS(apoc.convert.fromJsonMap(x.roiInfo).FB)) RETURN length(p) AS `length(path)`, [n in nodes(p) | [n.bodyId, n.type]] AS path, [x in relationships(p) | x.weight] AS weights")

shortestPathQuery = neuprint_fetch_custom(cypher = queryNow)
```

Create a Sankey plot of the shortest pathways
```{r}


allNames = c()
for (path in 1:length(shortestPathQuery$data)){
  for (link in 1:(shortestPathQuery$data[[path]][[1]]+1)){
    allNames <- append(allNames,shortestPathQuery$data[[path]][[2]][[link]][[2]])
  }
}

allNames <- unique(allNames) %>% sort()

SPGroups = c(length(allNames))
for (nm in 1:length(allNames)){
  SPGroups[nm] <- "other"
  if (grepl("FB",allNames[nm])){
    SPGroups[nm] <- "FB"
  }
  if (grepl("Q",allNames[nm])){
    SPGroups[nm] <- "FB-Q"
  }
  if (grepl("PB",allNames[nm])){
    SPGroups[nm] <- "PB"
  }
  if (grepl("Delta",allNames[nm])){
    SPGroups[nm] <- "Delta"
  }
}

allPre = c()
allPost = c()
allWeights = c()
for (path in 1:length(shortestPathQuery$data)){
  for (link in 1:shortestPathQuery$data[[path]][[1]]){
    preID = which(allNames %in% shortestPathQuery$data[[path]][[2]][[link]][[2]])
    allPre <- append(allPre,preID-1)
    postID = which(allNames %in% shortestPathQuery$data[[path]][[2]][[link+1]][[2]])
    allPost <- append(allPost,postID-1)
    allWeights <- append(allWeights,shortestPathQuery$data[[path]][[3]][[link]])  }
}

SPNodes = data.frame(name = allNames, group = SPGroups )
SPLinks = data.frame(source = allPre, target = allPost, value = allWeights)

library(networkD3)

sankeyNetwork(Links = SPLinks, Nodes = SPNodes, Source = "source", Target = "target", Value = "value", NodeID = "name", NodeGroup = "group", units = "synapses", fontSize = 12, nodeWidth = 30)

```

Find the paths between two given neurons that are at most x steps long
```{r}
cxnThresh = 3

inNrons1 = inputTypes[17] %>% paste(".*",sep="") %>% neuprint_search()
outNrons1 = outputTypes[19] %>% paste(".*",sep="") %>% neuprint_search()

queryNow = "MATCH p = (src :`hemibrain_Neuron` { bodyId: 974627674 })-[:ConnectsTo*0..3]->(dest:`hemibrain_Neuron`{ bodyId: 757694775 }) WHERE ALL (x in relationships(p) WHERE x.weight >= 10 AND EXISTS(apoc.convert.fromJsonMap(x.roiInfo).FB)) RETURN length(p) AS `length(path)`, [n in nodes(p) | [n.bodyId, n.type]] AS path, [x in relationships(p) | x.weight] AS weights"

# )

pathsQuery = neuprint_fetch_custom(cypher = queryNow)
```

Create a Sankey plot of these connections grouped by type
```{r}
allNames = c()
for (path in 1:length(pathsQuery$data)){
  for (link in 1:(pathsQuery$data[[path]][[1]]+1)){
    allNames <- append(allNames,pathsQuery$data[[path]][[2]][[link]][[2]])
  }
}

allNames <- unique(allNames) %>% sort()

SPGroups = c(length(allNames))
for (nm in 1:length(allNames)){
  SPGroups[nm] <- "other"
  if (grepl("FB",allNames[nm])){
    SPGroups[nm] <- "FB"
  }
  if (grepl("Q",allNames[nm])){
    SPGroups[nm] <- "FB-Q"
  }
  if (grepl("PB",allNames[nm])){
    SPGroups[nm] <- "PB"
  }
  if (grepl("Delta",allNames[nm])){
    SPGroups[nm] <- "Delta"
  }
}

allPre = c()
allPost = c()
allWeights = c()
for (path in 1:length(pathsQuery$data)){
  for (link in 1:pathsQuery$data[[path]][[1]]){
    preID = which(allNames %in% pathsQuery$data[[path]][[2]][[link]][[2]])
    allPre <- append(allPre,preID-1)
    postID = which(allNames %in% pathsQuery$data[[path]][[2]][[link+1]][[2]])
    allPost <- append(allPost,postID-1)
    allWeights <- append(allWeights,pathsQuery$data[[path]][[3]][[link]])  }
}

SPNodes = data.frame(name = allNames, group = SPGroups )
SPLinks = data.frame(source = allPre, target = allPost, value = allWeights)

library(networkD3)

sankeyNetwork(Links = SPLinks, Nodes = SPNodes, Source = "source", Target = "target", Value = "value", NodeID = "name", NodeGroup = "group", units = "synapses", fontSize = 12, nodeWidth = 30)
```

Create a Sankey plot of these connections for each individual neuron
```{r}
allNames = c()
allBodyIds = c()

for (path in 1:length(pathsQuery$data)){
  for (link in 1:(pathsQuery$data[[path]][[1]]+1)){
    if (!(pathsQuery$data[[path]][[2]][[link]][[1]] %in% allBodyIds)){
        allNames <- append(allNames,pathsQuery$data[[path]][[2]][[link]][[2]])
        allBodyIds <- append(allBodyIds,pathsQuery$data[[path]][[2]][[link]][[1]])
      }
  }
}

SPGroups = c(length(allNames))
for (nm in 1:length(allNames)){
  SPGroups[nm] <- "other"
  if (grepl("FB",allNames[nm])){
    SPGroups[nm] <- "FB"
  }
  if (grepl("Q",allNames[nm])){
    SPGroups[nm] <- "FB-Q"
  }
  if (grepl("PB",allNames[nm])){
    SPGroups[nm] <- "PB"
  }
  if (grepl("Delta",allNames[nm])){
    SPGroups[nm] <- "Delta"
  }
}

allPre = c()
allPost = c()
allWeights = c()
for (path in 1:length(pathsQuery$data)){
  for (link in 1:pathsQuery$data[[path]][[1]]){
    preID = which(allBodyIds %in% pathsQuery$data[[path]][[2]][[link]][[1]])
    allPre <- append(allPre,preID-1)
    postID = which(allBodyIds %in% pathsQuery$data[[path]][[2]][[link+1]][[1]])
    allPost <- append(allPost,postID-1)
    allWeights <- append(allWeights,pathsQuery$data[[path]][[3]][[link]])  }
}

SPNodes = data.frame(name = allNames, group = SPGroups )
SPLinks = data.frame(source = allPre, target = allPost, value = allWeights)

library(networkD3)

sankeyNetwork(Links = SPLinks, Nodes = SPNodes, Source = "source", Target = "target", Value = "value", NodeID = "name", NodeGroup = "group", units = "synapses", fontSize = 12, nodeWidth = 30)
```


Pull out an example Delta6
```{r}
D6s = neuprint_search("Delta6C.*")
D6syns = neuprint_get_synapses(D6s$bodyid[[1]])
D6syns <-  D6syns %>% mutate(name="D6")%>%
  mutate(x=as.numeric(x),y=as.numeric(y),z=as.numeric(z),prepost=as.logical(prepost))

ggplot(D6syns[which(D6syns$prepost == 1),]) + geom_point(aes(x,z,color= interaction(name,prepost))) +scale_color_brewer(palette="Set2")+coord_fixed(ratio = 1) + theme_void() + geom_point(data = D6syns[which(D6syns$prepost == 0),],aes(x,z,color= interaction(name,prepost))) +scale_color_brewer(palette="Set2")+coord_fixed(ratio = 1) + theme_void()

kmeanMat = D6syns[which(D6syns$prepost == 1),] %>% select(x,y,z)

maxClusts = 6
clustStats = data.frame(clustIDs = 1:maxClusts, tot.withinss = integer(maxClusts))
for (clust in 1:maxClusts){
  synClusts = kmeans(kmeanMat,clust, iter.max = 50, nstart = 10)
  clustStats$tot.withinss[clust] = synClusts$tot.withinss
}

ggplot(clustStats, aes(clustIDs, tot.withinss)) + geom_point() + ylim(0,5E9)

synClusts = kmeans(kmeanMat,3, iter.max = 50, nstart = 10)

ggplot(D6syns[which(D6syns$prepost == 1),], aes(x,z, color = as.factor(synClusts$cluster))) + geom_point()
```
