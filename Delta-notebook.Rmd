---
title: "Delta explorations"
output: html_notebook
---

Load the libraries
```{r}
library(nat)
library(neuprintr)
library(tidyverse)
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\pathways.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\visualizeConnectivityTables.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\neuprintQueryUtils.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\colorCodeLookup.R")
options(nat.plotengine = 'rgl')
```

Connect to neuprint
```{r}
neuprint_login()
```

"clean up" weight matrices
```{r}
# For each presynaptic type, find the weight matrix with the corresponding postsynaptic type. If the number of connections is less than the number of neurons in the presynaptic type (i.e. one of those neurons doesn't have a partner) or vice versa, remove those entries from the weight matrix


cleanUpConTab <- function(conTab){
  preTypes <- conTab$type.from %>% unique()
  postTypes <- conTab$type.to %>% unique()
  
  for (pre in 1:length(preTypes)){
    numPres = nrow(neuprint_search(paste0(preTypes[pre],".*")))
    for (post in 1:length(postTypes)){
      numPost = nrow(neuprint_search(paste0(postTypes[post],".*")))
      conSub <- conTab[which((grepl(preTypes[pre],conTab$type.from)) & 
                                         (grepl(postTypes[post],conTab$type.to))),]
      if ((nrow(conSub) < 0.5*numPres) | (nrow(conSub) < 0.5*numPost)){
        conTab <- conTab[which(!(grepl(preTypes[pre],conTab$type.from)) | 
                                         !(grepl(postTypes[post],conTab$type.to))),]
      }
    }
  }
  return(conTab)
}
```

Assign super types to a node 
```{r}
nodeSuperTypes <- function(nodes){
  nodes$superType <- c("other")
  nodes$superType[which(grepl("FB",nodes$name))] <- "FB"
  nodes$superType[which(grepl("Delta0",nodes$name))] <- "Delta0"
  nodes$superType[which(grepl("Delta6",nodes$name))] <- "Delta6"
  nodes$superType[which(grepl("PF",nodes$name))] <- "PF"
  nodes$superType[which(grepl("PFN",nodes$name))] <- "PFN"
  nodes$superType[which(grepl("PFL",nodes$name))] <- "PFL"
  nodes$superType[which(grepl("FC",nodes$name))] <- "FC"
  nodes$superType[which(grepl("FR",nodes$name))] <- "FR"
  nodes$superType[which(grepl("FS",nodes$name))] <- "FS"
  
  return(nodes)
}

```

Create x and y coordinates for a manual network layout of neurons
```{r}
super

```


Plot the connection of a given PFN type to its downstream partners
```{r}
# Load libraries for plotting
library(tidygraph)
library(ggraph)
library(gridExtra)

# Get the PFN types (which will specify the inputs) and specify the end types (outputs)
PFNTypes <- neuprint_search("PFN.*")$type %>% unique()
endTypes <- c("PFL","PFR","PFG","FC","FR","FS")

# Choose how many layers (between start and end) to step through in the network
stopLayer = 3

# Generate a graph for each PFN type
for (pf in 1:length(PFNTypes)){
  
  # Get the starting PFN type
  seedInput = PFNTypes[pf]
  
  # Step through the layers, getting the node names and connection matrix as you go
  layer = 1
  nodes <- data.frame(name = seedInput,layer = c(layer))
  while (layer < stopLayer) {
    layer <- layer + 1
    conTab <- getConnectionTable(getBodyIdsForList(nodes$name),"POST","FB",synThresh = 5)
    conTab <- conTab[which(!is.na(conTab$type.to) & !is.na(conTab$type.from)),]
    newTypes <- unique(c(conTab$type.from,conTab$type.to))
    newTypes <- newTypes[!(newTypes %in% nodes$name)]
    newNodes <- data.frame(name = newTypes, layer = layer)
    nodes <- rbind(nodes,newNodes)
  }
  
  # Clean up the columnar weight matrix
  conTabCol <- conTab[which(!grepl("FB",conTab$type.from) & !grepl("FB",conTab$type.to)),]
  conTabCol <- cleanUpConTab(conTabCol)
  
  # Get the colmnar nodes only
  nodes_Col <- nodes[which((nodes$name %in% conTabCol$type.to) | (nodes$name %in% conTabCol$type.from)),]
  
  # Specify superTypes for the different FB neurons
  nodes_Col <- nodeSuperTypes(nodes_Col)
  
  # Discard nodes in the final layer that aren't outputs
  nodes2keep <- which(nodes_Col$layer < stopLayer)
  for (kp in 1:length(endTypes))
    nodes2keep <- append(nodes2keep,
                         which(grepl(endTypes[kp],nodes_Col$name)))
  nodes2keep <- nodes2keep %>% unique() %>% sort()
  nodes_Col <- nodes_Col[nodes2keep,]
  
  # Link the x position of the node in the graph to its name
  nodes_Col$name <- factor(nodes_Col$name, levels = sort(as.character(unique(nodes_Col$name))))
  nodes_Col <- nodes_Col[order(nodes_Col$name),]
  rownames(nodes_Col) <- NULL
  nodes_Col$xpos <- 0.25*as.numeric(rownames(nodes_Col))
  
  # Add small offsets to the layers in order to see layer specific connectivity
  nodes_Col <- nodes_Col[order(nodes_Col$superType),]
  nodes_Col <- nodes_Col[order(nodes_Col$layer),]
  layerNums <- nodes_Col$layer %>% unique()
  for (l in 1:length(layerNums))
    nodes_Col$layer[which(nodes_Col$layer == layerNums[l])] <- layerNums[l] + 0.5*runif(length(which(nodes_Col$layer == layerNums[l])))-0.25
  
  nodes_Col$xpos <- 0.25*as.numeric(rownames(nodes_Col))
  
  edges_Col <- conTabCol[which((conTabCol$type.from %in% nodes_Col$name) & (conTabCol$type.to %in% nodes_Col$name)),] %>%
    mutate(to = sapply(type.to, function(f) which(f == nodes_Col$name)),
           from = sapply(type.from, function(f) which(f == nodes_Col$name)))
  
  edges_Col_Mean <- unique(edges_Col[,c('from','to')])
  meanWs <- c()
  for (i in 1:nrow(edges_Col_Mean)){
    meanWs <- append(meanWs,
                     mean(edges_Col[which((edges_Col$from == edges_Col_Mean$from[i]) & (edges_Col$to == edges_Col_Mean$to[i])),]$weightRelative))
  }
  edges_Col_Mean$weightRelative <- meanWs
  
  
  graph <- tbl_graph(nodes_Col,edges_Col_Mean)
  
  gg <-
    ggraph(graph,layout="manual",x=nodes_Col$xpos,y=nodes_Col$layer) + 
        geom_edge_fan(aes(width=weightRelative),colour="grey",alpha=0.5,
                      strength=1,
                      arrow = arrow(length = unit(2, "cm")),
                      end_cap = circle(2, 'cm')) + 
        geom_edge_loop(colour="grey",aes(direction=10,span=10,width=weightRelative),alpha=0.5) +
        geom_node_point(aes(color=superType),size=50) + 
        geom_node_text(aes(label=name),angle=40,size=24) +
        scale_y_reverse() + theme_classic() + theme(legend.text=element_text(size=36)) + 
    theme(legend.text=element_text(size=36),legend.title=element_text(size=36))
  for (l in 1:(length(layerNums)-1))
    gg <- gg + geom_hline(yintercept=l+0.5, linetype="dashed")
  
  conmatPlot <- plotConnectivityMatrix(conTab[which((conTab$type.from %in% nodes_Col$name) & (conTab$type.to %in% nodes_Col$name)),])
  conmatPlot <- structureMatrixPlotByType(conmatPlot)
  conmatPlot <- addMatrixPlotLabs(conmatPlot, "pre-synaptic neurons", "post-synaptic neurons", "FB")
  conmatPlot <- conmatPlot + theme(strip.text.x = element_text(size = 36),strip.text.y = element_text(size = 36,angle = 270))
  
  conmatPlotClean <- plotConnectivityMatrix(conTabCol[which((conTabCol$type.from %in% nodes_Col$name) & (conTabCol$type.to %in% nodes_Col$name)),])
  conmatPlotClean <- structureMatrixPlotByType(conmatPlotClean)
  conmatPlotClean <- addMatrixPlotLabs(conmatPlotClean, "pre-synaptic neurons", "post-synaptic neurons", "FB")
  conmatPlotClean <- conmatPlotClean + theme(strip.text.x = element_text(size = 36),strip.text.y = element_text(size = 36,angle = 270))

  gCM <- grid.arrange(conmatPlot,conmatPlotClean,nrow = 2)
  
  pdf(paste0("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\DeltaNetworkLinear_",seedInput,".pdf"), width = 100, height = 50)

  print(grid.arrange(gCM,gg,ncol = 2))

  dev.off()

}

```


Plot graph of Delta<->Delta connections
```{r}
preNeuron = c("Delta")
postNeuron = c("Delta")
slctROI = "FB"

# Get connectivity table
preIDs = getBodyIdsForList(preNeuron)
postIDs = getBodyIdsForList(postNeuron)
myConnections = getConnectionTable_forSubset(preIDs$bodyid,postIDs$bodyid, slctROI)

require(igraph)
# Reroganize to make graph with types instead of bodyids
graphData = data.frame(from = myConnections$type.from, to = myConnections$type.to, weight = myConnections$ROIweight)
graphData = graphData %>% group_by(from, to) %>% summarise(weight = mean(weight, na.rm = TRUE)) %>% ungroup()

# Cutoff low synapse counts (and compare connections before and after)
hist(graphData$weight, n=100)
cutoff = 2
graphData = graphData %>% filter(weight > cutoff)
hist(graphData$weight, n=100)

# Separate connections within a type and across types
graphData_noSelf = graphData %>% filter(as.character(from) != as.character(to))
graphData_toSelf = graphData %>% filter(as.character(from) == as.character(to))

# Pull out the nodes of the graph
nodes  = union(unique(graphData_noSelf$from), unique(graphData_noSelf$to))

# Process self connections (will serve as size of circles in plot)
graphData_selfFB = full_join(data.frame("from" = graphData_toSelf$from, "weight" = graphData_toSelf$weight), data.frame("from" = nodes))
graphData_selfFB$weight[is.na(graphData_selfFB$weight)] <- 0

# Create a graph object from the connections across types
connectGraph = graph_from_data_frame(graphData_noSelf)
connectGraph <- delete_edges(connectGraph, E(connectGraph)[weight<cutoff])
connectGraph

# Assign colors to the nodes from the lookup table
nodeCols = seq(1, length(nodes))
for (i in seq(1, length(nodes))) {
  nodeCols[i] = colors()[colorValueLookup$col[colorValueLookup$type == nodes[i]]]
}

# Make labels for the nodes in the graph
V(connectGraph)$label.color="black"
V(connectGraph)$label.cex=0.8
V(connectGraph)$label.dist=0

# Make the size of each node correspond to the number of self connections
V(connectGraph)$size = 7 + as.numeric(7*graphData_selfFB$weight/max(c(1, max(graphData_selfFB$weight) ) ) )
V(connectGraph)$vertex.frame.color="gray"
V(connectGraph)$color=nodeCols

# Set edge width based on weight:
E(connectGraph)$width <- E(connectGraph)$weight/5.
#change arrow size and edge color:
E(connectGraph)$arrow.size <- 1
#E(connectGraph)$edge.color <- "gray80"
edge.start <- ends(connectGraph, es=E(connectGraph), names=F)[,1]
edge.col = V(connectGraph)$color[edge.start]

l <- layout_with_fr(connectGraph) # layout_components

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\DeltaNetwork.pdf", width = 10, height = 10)#, units ="cm", dpi = 600)
plot(connectGraph,edge.color=edge.col, edge.curved=0.5, layout=l)  #vertex.shape="fcircle", 

```

Look at Delta6B inputs
```{r}
D6B_Pre <- getConnectionTable(getBodyIdsForList(c("Delta6B")),"PRE","FB")
D6B_Pre <- 
p <- connectivityBarPlot(D6B_Pre,"PRE") + ggtitle("Delta6B inputs")
print(p)
ggsave("Delta6BInputs.pdf", plot = last_plot(), device='pdf', 
       path = "C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\",
       scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
```

Find the shortest path between a given input and output neuron
```{r}
inNrons1 = inputTypes[17] %>% paste(".*",sep="") %>% neuprint_search()
outNrons1 = outputTypes[19] %>% paste(".*",sep="") %>% neuprint_search()

# Don't forget the min weight!!!
queryNow = "MATCH (a:`hemibrain_Neuron`{bodyId:" %>% paste0(inNrons1$bodyid[1]) %>% paste0("}), (b:`hemibrain_Neuron`{bodyId:") %>% paste0(outNrons1$bodyid[1]) %>% paste0("}), p = allShortestPaths((a)-[:ConnectsTo*]->(b)) WHERE ALL (x in relationships(p) WHERE x.weight >= 5 AND EXISTS(apoc.convert.fromJsonMap(x.roiInfo).FB)) RETURN length(p) AS `length(path)`, [n in nodes(p) | [n.bodyId, n.type]] AS path, [x in relationships(p) | x.weight] AS weights")

shortestPathQuery = neuprint_fetch_custom(cypher = queryNow)
```

Create a Sankey plot of the shortest pathways
```{r}


allNames = c()
for (path in 1:length(shortestPathQuery$data)){
  for (link in 1:(shortestPathQuery$data[[path]][[1]]+1)){
    allNames <- append(allNames,shortestPathQuery$data[[path]][[2]][[link]][[2]])
  }
}

allNames <- unique(allNames) %>% sort()

SPGroups = c(length(allNames))
for (nm in 1:length(allNames)){
  SPGroups[nm] <- "other"
  if (grepl("FB",allNames[nm])){
    SPGroups[nm] <- "FB"
  }
  if (grepl("Q",allNames[nm])){
    SPGroups[nm] <- "FB-Q"
  }
  if (grepl("PB",allNames[nm])){
    SPGroups[nm] <- "PB"
  }
  if (grepl("Delta",allNames[nm])){
    SPGroups[nm] <- "Delta"
  }
}

allPre = c()
allPost = c()
allWeights = c()
for (path in 1:length(shortestPathQuery$data)){
  for (link in 1:shortestPathQuery$data[[path]][[1]]){
    preID = which(allNames %in% shortestPathQuery$data[[path]][[2]][[link]][[2]])
    allPre <- append(allPre,preID-1)
    postID = which(allNames %in% shortestPathQuery$data[[path]][[2]][[link+1]][[2]])
    allPost <- append(allPost,postID-1)
    allWeights <- append(allWeights,shortestPathQuery$data[[path]][[3]][[link]])  }
}

SPNodes = data.frame(name = allNames, group = SPGroups )
SPLinks = data.frame(source = allPre, target = allPost, value = allWeights)

library(networkD3)

sankeyNetwork(Links = SPLinks, Nodes = SPNodes, Source = "source", Target = "target", Value = "value", NodeID = "name", NodeGroup = "group", units = "synapses", fontSize = 12, nodeWidth = 30)

```

Find the paths between two given neurons that are at most x steps long
```{r}
cxnThresh = 3

inNrons1 = inputTypes[17] %>% paste(".*",sep="") %>% neuprint_search()
outNrons1 = outputTypes[19] %>% paste(".*",sep="") %>% neuprint_search()

queryNow = "MATCH p = (src :`hemibrain_Neuron` { bodyId: 974627674 })-[:ConnectsTo*0..3]->(dest:`hemibrain_Neuron`{ bodyId: 757694775 }) WHERE ALL (x in relationships(p) WHERE x.weight >= 10 AND EXISTS(apoc.convert.fromJsonMap(x.roiInfo).FB)) RETURN length(p) AS `length(path)`, [n in nodes(p) | [n.bodyId, n.type]] AS path, [x in relationships(p) | x.weight] AS weights"

# )

pathsQuery = neuprint_fetch_custom(cypher = queryNow)
```

Create a Sankey plot of these connections grouped by type
```{r}
allNames = c()
for (path in 1:length(pathsQuery$data)){
  for (link in 1:(pathsQuery$data[[path]][[1]]+1)){
    allNames <- append(allNames,pathsQuery$data[[path]][[2]][[link]][[2]])
  }
}

allNames <- unique(allNames) %>% sort()

SPGroups = c(length(allNames))
for (nm in 1:length(allNames)){
  SPGroups[nm] <- "other"
  if (grepl("FB",allNames[nm])){
    SPGroups[nm] <- "FB"
  }
  if (grepl("Q",allNames[nm])){
    SPGroups[nm] <- "FB-Q"
  }
  if (grepl("PB",allNames[nm])){
    SPGroups[nm] <- "PB"
  }
  if (grepl("Delta",allNames[nm])){
    SPGroups[nm] <- "Delta"
  }
}

allPre = c()
allPost = c()
allWeights = c()
for (path in 1:length(pathsQuery$data)){
  for (link in 1:pathsQuery$data[[path]][[1]]){
    preID = which(allNames %in% pathsQuery$data[[path]][[2]][[link]][[2]])
    allPre <- append(allPre,preID-1)
    postID = which(allNames %in% pathsQuery$data[[path]][[2]][[link+1]][[2]])
    allPost <- append(allPost,postID-1)
    allWeights <- append(allWeights,pathsQuery$data[[path]][[3]][[link]])  }
}

SPNodes = data.frame(name = allNames, group = SPGroups )
SPLinks = data.frame(source = allPre, target = allPost, value = allWeights)

library(networkD3)

sankeyNetwork(Links = SPLinks, Nodes = SPNodes, Source = "source", Target = "target", Value = "value", NodeID = "name", NodeGroup = "group", units = "synapses", fontSize = 12, nodeWidth = 30)
```

Create a Sankey plot of these connections for each individual neuron
```{r}
allNames = c()
allBodyIds = c()

for (path in 1:length(pathsQuery$data)){
  for (link in 1:(pathsQuery$data[[path]][[1]]+1)){
    if (!(pathsQuery$data[[path]][[2]][[link]][[1]] %in% allBodyIds)){
        allNames <- append(allNames,pathsQuery$data[[path]][[2]][[link]][[2]])
        allBodyIds <- append(allBodyIds,pathsQuery$data[[path]][[2]][[link]][[1]])
      }
  }
}

SPGroups = c(length(allNames))
for (nm in 1:length(allNames)){
  SPGroups[nm] <- "other"
  if (grepl("FB",allNames[nm])){
    SPGroups[nm] <- "FB"
  }
  if (grepl("Q",allNames[nm])){
    SPGroups[nm] <- "FB-Q"
  }
  if (grepl("PB",allNames[nm])){
    SPGroups[nm] <- "PB"
  }
  if (grepl("Delta",allNames[nm])){
    SPGroups[nm] <- "Delta"
  }
}

allPre = c()
allPost = c()
allWeights = c()
for (path in 1:length(pathsQuery$data)){
  for (link in 1:pathsQuery$data[[path]][[1]]){
    preID = which(allBodyIds %in% pathsQuery$data[[path]][[2]][[link]][[1]])
    allPre <- append(allPre,preID-1)
    postID = which(allBodyIds %in% pathsQuery$data[[path]][[2]][[link+1]][[1]])
    allPost <- append(allPost,postID-1)
    allWeights <- append(allWeights,pathsQuery$data[[path]][[3]][[link]])  }
}

SPNodes = data.frame(name = allNames, group = SPGroups )
SPLinks = data.frame(source = allPre, target = allPost, value = allWeights)

library(networkD3)

sankeyNetwork(Links = SPLinks, Nodes = SPNodes, Source = "source", Target = "target", Value = "value", NodeID = "name", NodeGroup = "group", units = "synapses", fontSize = 12, nodeWidth = 30)
```


Pull out an example Delta6
```{r}
D6s = neuprint_search("Delta6C.*")
D6syns = neuprint_get_synapses(D6s$bodyid[[1]])
D6syns <-  D6syns %>% mutate(name="D6")%>%
  mutate(x=as.numeric(x),y=as.numeric(y),z=as.numeric(z),prepost=as.logical(prepost))

ggplot(D6syns[which(D6syns$prepost == 1),]) + geom_point(aes(x,z,color= interaction(name,prepost))) +scale_color_brewer(palette="Set2")+coord_fixed(ratio = 1) + theme_void() + geom_point(data = D6syns[which(D6syns$prepost == 0),],aes(x,z,color= interaction(name,prepost))) +scale_color_brewer(palette="Set2")+coord_fixed(ratio = 1) + theme_void()

kmeanMat = D6syns[which(D6syns$prepost == 1),] %>% select(x,y,z)

maxClusts = 6
clustStats = data.frame(clustIDs = 1:maxClusts, tot.withinss = integer(maxClusts))
for (clust in 1:maxClusts){
  synClusts = kmeans(kmeanMat,clust, iter.max = 50, nstart = 10)
  clustStats$tot.withinss[clust] = synClusts$tot.withinss
}

ggplot(clustStats, aes(clustIDs, tot.withinss)) + geom_point() + ylim(0,5E9)

synClusts = kmeans(kmeanMat,3, iter.max = 50, nstart = 10)

ggplot(D6syns[which(D6syns$prepost == 1),], aes(x,z, color = as.factor(synClusts$cluster))) + geom_point()
```
