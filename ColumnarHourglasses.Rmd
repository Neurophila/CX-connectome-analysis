---
title: "Inputs outputs of FB columnar neurons"
output: html_notebook
---

```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(ggforce)
library(igraph)
library(tidygraph)
library(ggraph)
source("neuprintQueryUtils.R")
## Some .R files containing utilities to build this type of tables/plots
source("table2ggraphUtils.R")
source("InputOutputByTypeUtils.R")
```


## PFNs
```{r}
PFNInOut <- buildInputsOutputsByType("PFN.*")
```

### FB
```{r}
fbROIs <- c("FBl1","FBl2","FBl3","FBl4","FBl5","FBl6","FBl7","FBl8")
```

```{r}
PFNInputsByLayer <- makePyramidGraph(PFNInOut,fbROIs,plot=TRUE,polarity = "inputs")
PFNOutputsByLayer <- makePyramidGraph(PFNInOut,fbROIs,plot=TRUE,polarity="outputs")
```

```{r}
PFNInputsByLayer
```

```{r}
ggsave("~/Desktop/PFN-FBInputsByFBlayer.svg",PFNInputsByLayer,width = 15,height=10)
ggsave("~/Desktop/PFN-FBOutputsByFBlayer.svg",PFNOutputsByLayer,width = 49,height=12)
```

### PFNs in the PB

```{r}
PFNPBInputs <- makePyramidGraph(PFNInOut,"PB",plot=TRUE,polarity = "inputs")
```

```{r}
PFNPBInputs
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/PB/pyramidPlots/PFN-InputsInPB.svg",PFNPBInputs,width = 15,height=10)
```

### PFNs in the NO

For the NO we need to break things down by side.
```{r}
PFNInOutLat <- lateralizeInputOutputList(PFNInOut)
```

```{r}
PFNNoOutputs <- makePyramidGraph(PFNInOutLat,c("NO2(R)","NO3(R)"),plot=TRUE,polarity = "outputs")
PFNNoInputs <- makePyramidGraph(PFNInOutLat,c("NO2(R)","NO3(R)"),plot=TRUE,polarity = "inputs")
```

```{r}
PFNNoOutputs
```

```{r}
PFNNoInputs
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NO/pyramidPlots/PFN-InputsNO.svg",PFNNoInputs,width = 49,height=12)
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NO/pyramidPlots/PFN-OutputsNO.svg",PFNNoOutputs,width = 49,height=12)
```

## PFRs
### FB
```{r}
PFRInOut <- buildInputsOutputsByType("PFR.*")
```

```{r}
fbROIs <- c("FBl1","FBl2","FBl3","FBl4","FBl5","FBl6","FBl7","FBl8")
```

```{r}
PFRInputsByLayer <- makePyramidGraph(PFRInOut,fbROIs,plot=TRUE,polarity = "inputs")
PFROutputsByLayer <-  makePyramidGraph(PFRInOut$outputs,fbROIs,plot=TRUE,polarity = "outputs")
```

```{r}
PFRInputsByLayer
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/FB/pyramidPlots/PFR-FBInputsByFBlayer.svg",PFRInputsByLayer,width = 49,height=12)
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/FB/pyramidPlots/PFR-FBOutputsByFBlayer.svg",PFROutputsByLayer,width = 49,height=12)
```

### PB inputs

```{r}
PFRInputsPB <- makePyramidGraph(PFRInOut,c("PB"),plot=TRUE,polarity = "inputs")
```

```{r}
PFRInputsPB
```
```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/PB/pyramidPlots/PFR-PBInputs.svg",PFRInputsPB,width = 15,height=12)
```

### Round body
Group L1 with R and R1 with L (innervation similar to PFL2/3)
```{r}
## Divide PFR taking into account the column 1 exception
PFRInOut <- redefineTypeByNameInList(PFRInOut,typeList = c("PFR_a","PFR_b"),pattern = "_L[2-7]|_R1",newPostFixes = c("_L*","_R*"))
```

```{r}
## Divide all the output neurons (except PFRs) according to Left/Right
PFRoutputTypes <- unique((PFRInOut[["outputs"]] %>% filter(!(grepl("PFR.*",type.to))))[["type.to"]])
```

```{r}
PFRInOut <- lateralizeInputOutputList(PFRInOut,typeList=PFRoutputTypes)
```


```{r}
PFROutputsRob <- makePyramidGraph(PFRInOut,c("ROB(R)"),plot=TRUE,polarity = "outputs")
```

```{r}
PFROutputsRob
```
This is an imperfect division (because PFRb(R1) is not a pure "instance", they go to different sides).
```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/Accessory/pyramidPlots/PFR-ROBOutputs.svg",PFROutputsRob,width = 15,height=12)
```

## PFLs

```{r}
PFLInOut <- buildInputsOutputsByType("PFL.*")
```

### FB
```{r}
PFLInputsByLayer <- makePyramidGraph(PFLInOut,fbROIs,plot=TRUE,polarity="inputs")
PFLOutputsByLayer <- makePyramidGraph(PFLInOut,fbROIs,plot=TRUE,polarity="outputs")
```

```{r}
PFLInputsByLayer
```
```{r}
PFLOutputsByLayer
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/FB/pyramidPlots/PFL-FBInputsByFBlayer.svg",PFLInputsByLayer,width = 49,height=12)
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/FB/pyramidPlots/PFL-FBOutputsByFBlayer.svg",PFLOutputsByLayer,width = 15,height=12)
```

### PB
```{r}
PFLPBInput <- makePyramidGraph(PFLInOut,ROIs="PB",polarity="inputs",plot=TRUE)
```

```{r}
PFLPBInput
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/PB/pyramidPlots/PFL-PBInputs.svg",PFLPBInput,width = 15,height=12)
```

### LAL
```{r}
## Divide PFL2 according to left/right
PFLInOutLat <- redefineTypeByNameInList(PFLInOut,typeList = c("PFL2"),pattern = "_L",newPostFixes = c("_L","_R"))
```

```{r}
## Divide PFL1  L/R taking into account the column 1 exception
PFLInOutLat <- redefineTypeByNameInList(PFLInOutLat,typeList = c("PFL1"),pattern = "_L[2-7]|_R1",newPostFixes = c("_L*","_R*"))
```

```{r}
## Divide PFL3  L/R taking into account the "irregular" neurons
PFLInOutLat <- redefineTypeByNameInList(PFLInOutLat,typeList = c("PFL3"),pattern = "(^.*_L(?!.*irreg))|(^.*_R.*irreg)",perl=TRUE,newPostFixes = c("_L*","_R*"))
```


```{r}
## Divide all the output neurons (except PFLs) according to Left/Right
outputTypes <- unique((PFLInOutLat[["outputs"]] %>% filter(!(grepl("PFL1.*|PFL2.*|PFL3.*",type.to))))[["type.to"]])
```

```{r}
PFLInOutLat <- lateralizeInputOutputList(PFLInOutLat,typeList=outputTypes)
```

```{r}
PFLLalOutputs <- makePyramidGraph(PFLInOutLat,ROIs = c("LAL(-GA)(R)"),polarity="outputs",plot = TRUE)
```

```{r}
PFLLalOutputs
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/LAL/pyramidPlots/PFL-LALOutputs.svg",PFLLalOutputs,width = 49,height=12)
```

## FQs
Too many of them for neuprint not to time out, so we need to build bit by bit
```{r}
FQInOut4 <- buildInputsOutputsByType("FQ4.*")
FQInOut6 <- buildInputsOutputsByType("FQ6.*")
```

```{r}
FQInOut7 <- buildInputsOutputsByType("FQ7.*")
FQInOut8 <- buildInputsOutputsByType("FQ8.*")
FQInOut9 <- buildInputsOutputsByType("FQ9.*")
FQInOut10 <- buildInputsOutputsByType("FQ10.*")
FQInOut11 <- buildInputsOutputsByType("FQ11.*")
FQInOut12 <- buildInputsOutputsByType("FQ12.*")
```



```{r}
FQInOut <- bind_InoutLists(FQInOut4,FQInOut6,FQInOut7,FQInOut8,FQInOut9,FQInOut10,FQInOut11,FQInOut12)
```

### FQ in the FB
Probably need to break that down more...

```{r}
FQInputsByLayer <- makePyramidGraph(FQInOut,fbROIs,plot=TRUE,polarity = "inputs")
FQOutputsByLayer <- makePyramidGraph(FQInOut,fbROIs,plot=TRUE,polarity = "outputs")
```

```{r}
FQInputsByLayer
```
```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/FB/pyramidPlots/FQs-FBInputsByFBlayer.svg",FQInputsByLayer,width = 49,height=12)
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/FB/pyramidPlots/FQs-FBOutputsByFBlayer.svg",FQOutputsByLayer,width = 49,height=12)
```

### FQs Outputs in Crepine
(Might need to break down)

```{r}
FQoutputsCre <- makePyramidGraph(FQInOut,c("CRE(R)"),polarity = "outputs",plot=TRUE)
```

```{r}
FQoutputsCre
```
```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/Accessory/pyramidPlots/FQs-CREOutputs.svg",FQoutputsCre,width = 25,height=12)
```

### FQ Outputs in SMP

Level of tracing in SMP might be a limitation her (a majority of the targets are bodyid, interesting only if we can place them in the context of the other outputs).
```{r}
FQoutputsSMP <- makePyramidGraph(FQInOut,c("SMP(R)","SMP(L)"),polarity = "outputs",plot=TRUE)
```

```{r}
FQoutputsSMP
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/Accessory/pyramidPlots/FQs-SMPOutputs.svg",FQoutputsSMP,width = 49,height=12)
```
