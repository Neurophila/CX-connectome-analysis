---
title: "Notebook analyzing the input and output pathways of the EB"
output:
  html_document:
    df_print: paged
---

# Command to clear environment is: rm(list = ls(all.names = TRUE))
# Load libraries
```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(dplyr)
options(nat.plotengine = 'rgl')
```


# Configurable inputs: choose ROI and Save directory
```{r}

# The region of interest.
ROI="EB"  

# Directory to save data to.
SaveDir="Z:/Cx_Connectome/BradData/EB_Analysis/"


```

# Create save directory if it doesnt exists yet
```{r}
if (!dir.exists(SaveDir)){dir.create(SaveDir)}
```

# Connect to neuprint server.
```{r}
neuprint_login()
```


### Some custom functions (Should be called from R function in future)
```{r}
get_rois_df <- function (){
  rois = neuprint_ROIs()
  return (data.frame(keyName=names(rois), value=rois, row.names=NULL))
}

renameRoiColumn <- function(df, slctROI) {
  df = df %>% rename_at(vars(starts_with(slctROI)), funs(str_replace(., slctROI, "ROI")))
  df = df %>%rename_at(vars(ends_with(".pre")), funs(str_replace(., ".pre", "_pre")))
  df = df %>%rename_at(vars(ends_with(".post")), funs(str_replace(., ".post", "_post")))
  df = df %>%rename_all(funs(str_replace(., "\\(", "")))
  df = df %>%rename_all(funs(str_replace(., "\\)", "")))
  
  return (df)
}

#remove missing values
cleanup <- function(df) {
  df <- unnest(df, colnames(df))
  df <- na.omit(df)
  df$bodyname <- as.factor(df$bodyname)
  df$bodytype <- as.factor(df$bodytype)
  
  return (df)
}
```


### Get neuprint ROIs and reformat to data frame
```{r}
roisDf = get_rois_df()
```


### Get neurons in ROI
```{r}
slctROI = ROI
pairedRegion = FALSE

if (pairedRegion) {
  roiR_Connect = neuprint_find_neurons( paste(slctROI, "(R)", sep=""), all_segments = FALSE )
  roiL_Connect = neuprint_find_neurons( paste(slctROI, "(L)", sep=""), all_segments = FALSE )
} else {
  roi_Connect = neuprint_find_neurons(slctROI, all_segments = FALSE) #not currently working for "NO"
}
```


# Remove rows where bodytype is "NA", converte name and type to factors, join data from left and right side
```{r message=FALSE, warning=FALSE}
if (pairedRegion) {
  
  roiR_Connect <- cleanup(roiR_Connect)
  roiL_Connect <- cleanup(roiL_Connect)
  
  #rename ROI columns 
  roiR_Connect = renameRoiColumn(roiR_Connect, slctROI)
  roiL_Connect = renameRoiColumn(roiL_Connect, slctROI)
  
  # join data from paired ROI
  roi_Connect = full_join(roiR_Connect,roiL_Connect)
  
  # get full synaptic count
  roi_Connect = roi_Connect %>% rowwise() %>%  mutate(ROI_n_pre = sum(ROIR_pre, ROIL_pre, na.rm = TRUE),  
                                                     ROI_n_post = sum(ROIR_post, ROIL_post, na.rm = TRUE)) %>% 
  ungroup()
  
} else {
  roi_Connect <- cleanup(roi_Connect)
  roi_Connect = renameRoiColumn(roi_Connect, slctROI)
}

```


# Rename to my variable names- this will be changed when the above is an R function
```{r}
NamedBodies=roi_Connect
remove(roi_Connect)
```


# Get total synapses (Pre+Post) and the relative percent of Pre and Post synapses in the ROI.
```{r}

# Compute the total number of synapses in the ROI
NamedBodies=mutate(NamedBodies, PrePost_Syns = (NamedBodies$ROI_pre + NamedBodies$ROI_post))

# Compute the percent of each body's PRE synapses in the ROI. 
NamedBodies=mutate(NamedBodies, Pre_Relative = NamedBodies$ROI_pre/unlist(NamedBodies$npre))
NamedBodies$Pre_Relative[is.nan(NamedBodies$Pre_Relative)] = 0

# Compute the percent of each body's POST synapses in the ROI.
NamedBodies=mutate(NamedBodies, Post_Relative = NamedBodies$ROI_post/unlist(NamedBodies$npost) )
NamedBodies$Post_Relative[is.nan(NamedBodies$Post_Relative)] = 0

# Average the relative PRE and relative POST synapses. It's best to average after computing the relative PRE and relative POST
# so that the measure isn't biased by there being more post synapses than pre synapses on average. 
NamedBodies=mutate(NamedBodies, PrePost_Relative = (Pre_Relative+Post_Relative)/2)

```


# Get Pre-to-Post connection table.
```{r}

# Pre-to-Post connections for named bodies (return all segements and filter) --> subet at end is important or it returns bodyids not contained in NamedBodies
NamedConnectTable = neuprint_connection_table(NamedBodies$bodyid,"PRE",ROI, all_segments=FALSE)   %>%
                         mutate( PreName =neuprint_get_meta(bodyid)[["name"]], PostName = neuprint_get_meta(partner)[["name"]] )   %>% 
                         mutate( PreType =neuprint_get_meta(bodyid)[["type"]], PostType = neuprint_get_meta(partner)[["type"]])   %>%  
                         group_by(PreName) %>% 
                         ungroup() %>%
                         rename(Pre_bodyid = bodyid, Post_bodyid = partner)
NamedConnectTable = subset(NamedConnectTable, Pre_bodyid %in% as.numeric(NamedBodies$bodyid) & Post_bodyid %in% as.numeric(NamedBodies$bodyid) ) 

```


# Calculate the max PRE weight and max POST weight for each bodyID
```{r}

# Loop over pre-synaptic neurons and find max output weight
PreMaxWeights=numeric()
for (prepre in (1:length(NamedBodies$bodyid)) )
  {
  Temp=subset(NamedConnectTable, NamedConnectTable$Pre_bodyid==unlist(NamedBodies$bodyid[[prepre]]) )
  if (length(Temp$Pre_bodyid)==0){PreMaxWeights[prepre]=0
  }else{PreMaxWeights[prepre]=max(Temp$weight)}
}

# Loop over post-synaptic neurons and find max output weight
PostMaxWeights=numeric()
for (postpost in (1:length(NamedBodies$bodyid)) )
  {
  Temp=subset(NamedConnectTable, NamedConnectTable$Post_bodyid==unlist(NamedBodies$bodyid[[postpost]]) )
  if (length(Temp$Post_bodyid)==0){PostMaxWeights[postpost]=0
  }else{PostMaxWeights[postpost]=max(Temp$weight)}
}
remove(Temp)

# Add data to NamedBodies dataframe
NamedBodies=mutate(NamedBodies, PreMax = PreMaxWeights)
NamedBodies=mutate(NamedBodies, PostMax = PostMaxWeights)
NamedBodies=mutate(NamedBodies, PrePost_Max = (PreMaxWeights+PostMaxWeights))


```


# Get the average number of Pre and Post synapses for each neuron type for both relative and absolute synapse counts.
```{r}

NamedBodies_byType <- aggregate(x=NamedBodies[c(paste(ROI, ".pre",sep=""),paste(ROI, ".post",sep=""),"PrePost_Syns","Pre_Relative",
                                                "Post_Relative","PrePost_Relative","PreMax","PostMax","PrePost_Max")],by=list(unlist(NamedBodies$bodytype[])), FUN=mean)
names(NamedBodies_byType) <- c("Type","PreSyns", "PostSyns","PrePost_Syns","Pre_Relative","Post_Relative","PrePost_Relative","PreMax","PostMax","PrePost_Max")

```


# Make scatter plot of max pre and post synaptic weight.
```{r}

# Interactive plot of maximum pre vs post synapse weight for named neuron types, where cursor brings up neuron type name
f <- list(size = 18, color = "black")
p3a <- plot_ly(type = 'scatter', x = NamedBodies_byType$PreMax, y = NamedBodies_byType$PostMax, mode='markers',
  text = paste("Type: ", NamedBodies_byType$Type )) %>% 
  layout(xaxis = list(title = paste("Max PRE Weight in", ROI),titlefont = f), yaxis = list(title = paste("Max POST Weight in",ROI),titlefont = f), 
         title=" \n \n  Each point is a neuron type")
htmlwidgets::saveWidget(as_widget(p3a), paste(SaveDir,"Pre_Vs_Post_MaxWeightsPerType_widget.html",sep=""))
remove(p3a)


# Interactive plot of maximum pre+post weight VS relative pre+post weight
f <- list(size = 18, color = "black")
p3b <- plot_ly(type = 'scatter', x = NamedBodies_byType$PrePost_Max, y = NamedBodies_byType$PrePost_Relative, mode='markers',
  text = paste("Type: ", NamedBodies_byType$Type )) %>% 
  layout(xaxis = list(title = paste("Max PRE+POST Weight in", ROI),titlefont = f), yaxis = list(title = paste("Relative Pre+POST synapses in",ROI),titlefont = f), 
         title=" \n \n  Each point is a neuron type")
htmlwidgets::saveWidget(as_widget(p3b), paste(SaveDir,"PrePostMax_Vs_PrePostRelativeSyns_PerType.html",sep=""))
remove(p3b,f)


```


# Exclude neurons not in the EB if they dont have a max pre or post weight greater than 10
```{r}

# First subset the type data frame
GoodNeuronTypes = NamedBodies_byType$PreMax > 10 | NamedBodies_byType$PostMax > 10 
ExcludedNeurons_byType=subset(NamedBodies_byType,!GoodNeuronTypes)
NamedBodies_byType=subset(NamedBodies_byType,GoodNeuronTypes)

# Now subset the neurons themselves based on type
GoodNeurons = NamedBodies$bodytype %in% NamedBodies_byType$Type
ExcludedNeurons=subset(NamedBodies,!GoodNeurons)
NamedBodies=subset(NamedBodies,GoodNeurons)


```


# Re-compute the Pre-to-Post connection table.
```{r}

# Pre-to-Post connections for named bodies (return all segements and filter) --> subet at end is important or it returns bodyids not contained in NamedBodies
NamedConnectTable = neuprint_connection_table(NamedBodies$bodyid,"PRE",ROI, all_segments=FALSE)   %>%
                         mutate( PreName =neuprint_get_meta(bodyid)[["name"]], PostName = neuprint_get_meta(partner)[["name"]] )   %>% 
                         mutate( PreType =neuprint_get_meta(bodyid)[["type"]], PostType = neuprint_get_meta(partner)[["type"]])   %>%  
                         group_by(PreName) %>% 
                         ungroup() %>%
                         rename(Pre_bodyid = bodyid, Post_bodyid = partner)
NamedConnectTable = subset(NamedConnectTable, Pre_bodyid %in% as.numeric(NamedBodies$bodyid) & Post_bodyid %in% as.numeric(NamedBodies$bodyid) ) 

```


# Get average connection table, grouped by neuron type
```{r}

# Average weights by neuron type
NamedConnectTable_byType = aggregate(x=NamedConnectTable$weight,
          by=list(NamedConnectTable$PreType, NamedConnectTable$PostType), FUN=mean)
names(NamedConnectTable_byType) <- c("PreType", "PostType","weight")


```


# Plot adjacency matrix of types, with clustering
```{r}

## Get adjacency matrix (All-to-All)
UniqueNamedBodies=unique(NamedBodies$bodytype)
AdjacentMat_byType = matrix(0, nrow = length(UniqueNamedBodies), ncol = length(UniqueNamedBodies))
rownames(AdjacentMat_byType) = colnames(AdjacentMat_byType) = unlist(UniqueNamedBodies)
for (val in 1:nrow(NamedConnectTable_byType)){AdjacentMat_byType[ as.character(NamedConnectTable_byType$PreType[val]),
                        as.character(NamedConnectTable_byType$PostType[val])] = NamedConnectTable_byType$weight[val] }


## Do some clustering for visualization purposes
SynThresh=10
SymmetricBinary_Matix = AdjacentMat_byType + t(AdjacentMat_byType)
SymmetricBinary_Matix[SymmetricBinary_Matix<SynThresh]=0
SymmetricBinary_Matix[SymmetricBinary_Matix>=SynThresh]=1
dist_mat <- dist(SymmetricBinary_Matix, method = 'binary')
hclust_avg <- hclust(dist_mat, method = 'average')

# Sort adjacency matrix
SortedWeightMatrix=AdjacentMat_byType[hclust_avg$order,]
SortedWeightMatrix=SortedWeightMatrix[,hclust_avg$order]

# Plot clusters
PlotSynThresh=10
png(file=paste(SaveDir,"NeuronTypeCluster.png",sep=""), width=20, height=8, units='in', res=500)
plot(hclust_avg) + theme(text = element_text(size=16))
dev.off()

# Plot unsorted and sorted adjacency matrices
xticks <- list(autotick = FALSE, ticks = "outside", tick0 = 0, dtick = 1, ticklen = 1,
  tickwidth = 1, tickcolor = toRGB("black"),title="PRE")
yticks <- list(autotick = FALSE, ticks = "outside", tick0 = 0, dtick = 1, ticklen = 1,
  tickwidth = 1, tickcolor = toRGB("black"),title="POST")

PlotDataType= AdjacentMat_byType
PlotDataType[PlotDataType<PlotSynThresh]=0
PlotDataType= replace(PlotDataType, which( PlotDataType==0), NA)
p4 <- plot_ly(x = rownames(PlotDataType), y = colnames(PlotDataType), z = PlotDataType, type = "heatmap") %>%
 layout(xaxis = yticks, yaxis = xticks, title=paste("Unsorted Adjacency Matrix of neuron types, threshold at ",PlotSynThresh, " synapses"))
htmlwidgets::saveWidget(as_widget(p4), paste(SaveDir,"UnsortedAdjacencyMatrix_byType.html",sep=""))
remove(p4)

PlotDataType= SortedWeightMatrix
PlotDataType[PlotDataType<PlotSynThresh]=0
PlotDataType= replace(PlotDataType, which( PlotDataType==0), NA)
p5 <- plot_ly(x = rownames(PlotDataType), y = colnames(PlotDataType), z = PlotDataType, type = "heatmap") %>%
 layout(xaxis = yticks, yaxis = xticks, title=paste("Sorted Adjacency Matrix of neuron types, threshold at ",PlotSynThresh, " synapses"))
htmlwidgets::saveWidget(as_widget(p5), paste(SaveDir,"SortedAdjacencyMatrix_byType.html",sep=""))

remove(yticks, xticks, PlotDataType, p5)

```



















### Filter
Select "significant" neurons, i.e. neurons that make a significant number of connections in the respective ROI, based on 
  (a) consistently high pre- and postsynaptic connections across neurons of the same type (mean > minSynapses = 10)
  (b) large total number of pre- and postsynaptic connections across neurons of the same type (sum > minSumSynapses = 30)

```{r}
minSynapses = 10
minSumSynapses = 30
```

-> Compute statistics across neurons of the same bodytype
```{r}
roi_synStats = roi_Connect %>% group_by(bodytype) %>% summarise(mean_pre = mean(ROI_pre),
                                                                mean_post = mean(ROI_post),
                                                                sum_pre = sum(ROI_pre),
                                                                sum_post = sum(ROI_post),
                                                                fract_pre = mean(ROI_pre/npre),
                                                                fract_post = mean(ROI_post/npost),
                                                                fract_all = mean((ROI_pre+ROI_post)/(npost + npre)))
```


```{r}

roi_Connect_filt = full_join(
                      full_join(filter(roi_Connect, bodytype %in% filter(roi_synStats, mean_pre >= minSynapses)$bodytype),
                                filter(roi_Connect, bodytype %in% filter(roi_synStats, mean_post >= minSynapses)$bodytype)),
                      full_join(filter(roi_Connect, bodytype %in% filter(roi_synStats, sum_pre >= minSumSynapses)$bodytype),
                                filter(roi_Connect, bodytype %in% filter(roi_synStats, sum_post >= minSumSynapses)$bodytype)))


```



### Characterize input and output regions of NO neurons

```{r}
roi_Connect_rois = neuprint_get_roiInfo(roi_Connect_filt$bodyid)

roi_Connect_rois =  mutate(roi_Connect_rois,
                        name = neuprint_get_meta(bodyid)$name,
                        type = neuprint_get_meta(bodyid)$type,
                        pre = neuprint_get_meta(bodyid)$pre,
                        post = neuprint_get_meta(bodyid)$post) 
```



```{r message=FALSE, warning=FALSE}

# reorganize such that ROI, #pre and #post become variables
roi_Connect_rois_df = data.frame(bodyid = numeric(),
                              name = character(),
                              type = character(),
                              roi = character(),
                              prepost = character(),
                              count = numeric())


for (roi in as.character(colnames(roi_Connect_rois))[2:(length(colnames(roi_Connect_rois))-4)]) {

  if (length(as.character(filter(roisDf,value == unlist(strsplit(roi, "[.]"))[1])$keyName)) == 1) next
  
  roiname = as.character(unlist(strsplit(roi, "[.]"))[1])
  side = as.character(unlist(strsplit(roiname, "[(]"))[2])
  roi_Connect_roi = data.frame(bodyid = roi_Connect_rois$bodyid,
                            name = roi_Connect_rois$name, 
                            type = roi_Connect_rois$type,
                            roi = as.character(unlist(strsplit(roiname, "[(]"))[1]),
                            hemisphere = as.character(unlist(strsplit(side, "[)]"))[1]),
                            prepost = unlist(strsplit(roi, "[.]"))[2],
                            count = ( as.numeric(roi_Connect_rois[[roi]]) ) ) 
                            #count = ( as.numeric(roi_Connect_rois[[roi]]) / (roi_Connect_rois$pre + roi_Connect_rois$post) ) )
  roi_Connect_rois_df = bind_rows(roi_Connect_rois_df, roi_Connect_roi)
}

```



```{r message=FALSE, warning=FALSE}
roi_Connect_rois_df = filter(roi_Connect_rois_df, count > minSynapses)
roi_Connect_rois_df = filter(roi_Connect_rois_df, type %in% unique(roi_Connect_filt$bodytype))
```



```{r}
ggplot(roi_Connect_rois_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(cols=vars(prepost)) + #, rows = vars(hemisphere)
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)

#ggsave(paste(slctROI,"inputOutputRegions_perType.pdf",sep="_"), plot = last_plot(), device='pdf', path = "../neuprintR_analysis_plots/",
 # scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
```


```{r}
ggplot(roi_Connect_rois_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(. ~ hemisphere + prepost) +
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)

#ggsave(paste(slctROI,"inputOutputRegions_perType_perROIside.pdf",sep="_"), plot = last_plot(), device='pdf', path = "../neuprintR_analysis_plots/",
#  scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
```


### Characterize input and output regions of NO neurons *within the NO*
Regions to look at
```{r}
regs = c("NO1(L)","NO1(R)","NO2(L)","NO2(R)","NO3(L)","NO3(R)")
```

```{r message=FALSE, warning=FALSE}
# reorganize such that ROI, #pre and #post become variables
roi_Connect_intraNO_df = data.frame(bodyid = numeric(),
                              name = character(),
                              type = character(),
                              roi = character(),
                              prepost = character(),
                              count = numeric())

for (roi in as.character(colnames(roi_Connect_rois))[2:(length(colnames(roi_Connect_rois))-4)]) {
  roiname = as.character(unlist(strsplit(roi, "[.]"))[1])
  side = as.character(unlist(strsplit(roiname, "[(]"))[2])
    
  if (roiname %in% regs) {
      roi_Connect_no = data.frame(bodyid = roi_Connect_rois$bodyid,
                                  name = roi_Connect_rois$name, 
                                  type = roi_Connect_rois$type,
                                  roi = as.character(unlist(strsplit(roiname, "[(]"))[1]),
                                  hemisphere = as.character(unlist(strsplit(side, "[)]"))[1]),
                                  prepost = unlist(strsplit(roi, "[.]"))[2],
                                  count = ( as.numeric(roi_Connect_rois[[roi]]) ) ) 
      roi_Connect_intraNO_df = bind_rows(roi_Connect_intraNO_df, roi_Connect_no)
  }
}
```

```{r message=FALSE, warning=FALSE}
roi_Connect_intraNO_df = filter(roi_Connect_intraNO_df, count > minSynapses)
roi_Connect_intraNO_df = filter(roi_Connect_intraNO_df, type %in% unique(roi_Connect_filt$bodytype))
```

```{r}
ggplot(roi_Connect_intraNO_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(.~ prepost) +
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)

ggplot(roi_Connect_intraNO_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(.~ hemisphere + prepost) +
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)
```



