---
title: "Notebook analyzing the input and output pathways of the EB"
output:
  html_document:
    df_print: paged
---

# Command to clear environment is: rm(list = ls(all.names = TRUE))
# Load libraries
```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(dplyr)
options(nat.plotengine = 'rgl')
```


# Configurable inputs: choose ROI and Save directory
```{r}

# The region of interest.
ROI="EB"  

# Directory to save data to.
SaveDir="Z:/Cx_Connectome/BradData/EB_Analysis/"


```

# Create save directory if it doesnt exists yet
```{r}
if (!dir.exists(SaveDir)){dir.create(SaveDir)}
```

# Connect to neuprint server.
```{r}
neuprint_login()
```

# Get general functions
```{r}
source("inputOutputRegionVis.r")
source("GetNeuronsInRoi.R")
```

### Get neuprint ROIs and reformat to data frame
```{r}
roisDf = get_rois_df()
```


### Get neurons in the ROI
```{r}
NamedBodies=Get_AllNeurons_InRoi(ROI, FALSE)
```


### Threshold neurons 
```{r}
PreMaxThresh=10
PostMaxThresh=10
GoodNeurons=SynapseStats_And_Threshold(NamedBodies, SaveDir, PreMaxThresh, PostMaxThresh)
```








# Re-compute the Pre-to-Post connection table.
```{r}

# Pre-to-Post connections for named bodies (return all segements and filter) --> subet at end is important or it returns bodyids not contained in NamedBodies
NamedConnectTable = neuprint_connection_table(NamedBodies$bodyid,"PRE",ROI, all_segments=FALSE)   %>%
                         mutate( PreName =neuprint_get_meta(bodyid)[["name"]], PostName = neuprint_get_meta(partner)[["name"]] )   %>% 
                         mutate( PreType =neuprint_get_meta(bodyid)[["type"]], PostType = neuprint_get_meta(partner)[["type"]])   %>%  
                         group_by(PreName) %>% 
                         ungroup() %>%
                         rename(Pre_bodyid = bodyid, Post_bodyid = partner)
NamedConnectTable = subset(NamedConnectTable, Pre_bodyid %in% as.numeric(NamedBodies$bodyid) & Post_bodyid %in% as.numeric(NamedBodies$bodyid) ) 

```


# Get average connection table, grouped by neuron type
```{r}

# Average weights by neuron type
NamedConnectTable_byType = aggregate(x=NamedConnectTable$weight,
          by=list(NamedConnectTable$PreType, NamedConnectTable$PostType), FUN=mean)
names(NamedConnectTable_byType) <- c("PreType", "PostType","weight")


```


# Plot adjacency matrix of types, with clustering
```{r}

## Get adjacency matrix (All-to-All)
UniqueNamedBodies=unique(NamedBodies$bodytype)
AdjacentMat_byType = matrix(0, nrow = length(UniqueNamedBodies), ncol = length(UniqueNamedBodies))
rownames(AdjacentMat_byType) = colnames(AdjacentMat_byType) = unlist(UniqueNamedBodies)
for (val in 1:nrow(NamedConnectTable_byType)){AdjacentMat_byType[ as.character(NamedConnectTable_byType$PreType[val]),
                        as.character(NamedConnectTable_byType$PostType[val])] = NamedConnectTable_byType$weight[val] }


## Do some clustering for visualization purposes
SynThresh=10
SymmetricBinary_Matix = AdjacentMat_byType + t(AdjacentMat_byType)
SymmetricBinary_Matix[SymmetricBinary_Matix<SynThresh]=0
SymmetricBinary_Matix[SymmetricBinary_Matix>=SynThresh]=1
dist_mat <- dist(SymmetricBinary_Matix, method = 'binary')
hclust_avg <- hclust(dist_mat, method = 'average')

# Sort adjacency matrix
SortedWeightMatrix=AdjacentMat_byType[hclust_avg$order,]
SortedWeightMatrix=SortedWeightMatrix[,hclust_avg$order]

# Plot clusters
PlotSynThresh=10
png(file=paste(SaveDir,"NeuronTypeCluster.png",sep=""), width=20, height=8, units='in', res=500)
plot(hclust_avg) + theme(text = element_text(size=16))
dev.off()

# Plot unsorted and sorted adjacency matrices
xticks <- list(autotick = FALSE, ticks = "outside", tick0 = 0, dtick = 1, ticklen = 1,
  tickwidth = 1, tickcolor = toRGB("black"),title="PRE")
yticks <- list(autotick = FALSE, ticks = "outside", tick0 = 0, dtick = 1, ticklen = 1,
  tickwidth = 1, tickcolor = toRGB("black"),title="POST")

PlotDataType= AdjacentMat_byType
PlotDataType[PlotDataType<PlotSynThresh]=0
PlotDataType= replace(PlotDataType, which( PlotDataType==0), NA)
p4 <- plot_ly(x = rownames(PlotDataType), y = colnames(PlotDataType), z = PlotDataType, type = "heatmap") %>%
 layout(xaxis = yticks, yaxis = xticks, title=paste("Unsorted Adjacency Matrix of neuron types, threshold at ",PlotSynThresh, " synapses"))
htmlwidgets::saveWidget(as_widget(p4), paste(SaveDir,"UnsortedAdjacencyMatrix_byType.html",sep=""))
remove(p4)

PlotDataType= SortedWeightMatrix
PlotDataType[PlotDataType<PlotSynThresh]=0
PlotDataType= replace(PlotDataType, which( PlotDataType==0), NA)
p5 <- plot_ly(x = rownames(PlotDataType), y = colnames(PlotDataType), z = PlotDataType, type = "heatmap") %>%
 layout(xaxis = yticks, yaxis = xticks, title=paste("Sorted Adjacency Matrix of neuron types, threshold at ",PlotSynThresh, " synapses"))
htmlwidgets::saveWidget(as_widget(p5), paste(SaveDir,"SortedAdjacencyMatrix_byType.html",sep=""))

remove(yticks, xticks, PlotDataType, p5)

```



















### Filter
Select "significant" neurons, i.e. neurons that make a significant number of connections in the respective ROI, based on 
  (a) consistently high pre- and postsynaptic connections across neurons of the same type (mean > minSynapses = 10)
  (b) large total number of pre- and postsynaptic connections across neurons of the same type (sum > minSumSynapses = 30)

```{r}
minSynapses = 10
minSumSynapses = 30
```

-> Compute statistics across neurons of the same bodytype
```{r}
roi_synStats = roi_Connect %>% group_by(bodytype) %>% summarise(mean_pre = mean(ROI_pre),
                                                                mean_post = mean(ROI_post),
                                                                sum_pre = sum(ROI_pre),
                                                                sum_post = sum(ROI_post),
                                                                fract_pre = mean(ROI_pre/npre),
                                                                fract_post = mean(ROI_post/npost),
                                                                fract_all = mean((ROI_pre+ROI_post)/(npost + npre)))
```


```{r}

roi_Connect_filt = full_join(
                      full_join(filter(roi_Connect, bodytype %in% filter(roi_synStats, mean_pre >= minSynapses)$bodytype),
                                filter(roi_Connect, bodytype %in% filter(roi_synStats, mean_post >= minSynapses)$bodytype)),
                      full_join(filter(roi_Connect, bodytype %in% filter(roi_synStats, sum_pre >= minSumSynapses)$bodytype),
                                filter(roi_Connect, bodytype %in% filter(roi_synStats, sum_post >= minSumSynapses)$bodytype)))


```



### Characterize input and output regions of NO neurons

```{r}
roi_Connect_rois = neuprint_get_roiInfo(roi_Connect_filt$bodyid)

roi_Connect_rois =  mutate(roi_Connect_rois,
                        name = neuprint_get_meta(bodyid)$name,
                        type = neuprint_get_meta(bodyid)$type,
                        pre = neuprint_get_meta(bodyid)$pre,
                        post = neuprint_get_meta(bodyid)$post) 
```



```{r message=FALSE, warning=FALSE}

# reorganize such that ROI, #pre and #post become variables
roi_Connect_rois_df = data.frame(bodyid = numeric(),
                              name = character(),
                              type = character(),
                              roi = character(),
                              prepost = character(),
                              count = numeric())


for (roi in as.character(colnames(roi_Connect_rois))[2:(length(colnames(roi_Connect_rois))-4)]) {

  if (length(as.character(filter(roisDf,value == unlist(strsplit(roi, "[.]"))[1])$keyName)) == 1) next
  
  roiname = as.character(unlist(strsplit(roi, "[.]"))[1])
  side = as.character(unlist(strsplit(roiname, "[(]"))[2])
  roi_Connect_roi = data.frame(bodyid = roi_Connect_rois$bodyid,
                            name = roi_Connect_rois$name, 
                            type = roi_Connect_rois$type,
                            roi = as.character(unlist(strsplit(roiname, "[(]"))[1]),
                            hemisphere = as.character(unlist(strsplit(side, "[)]"))[1]),
                            prepost = unlist(strsplit(roi, "[.]"))[2],
                            count = ( as.numeric(roi_Connect_rois[[roi]]) ) ) 
                            #count = ( as.numeric(roi_Connect_rois[[roi]]) / (roi_Connect_rois$pre + roi_Connect_rois$post) ) )
  roi_Connect_rois_df = bind_rows(roi_Connect_rois_df, roi_Connect_roi)
}

```



```{r message=FALSE, warning=FALSE}
roi_Connect_rois_df = filter(roi_Connect_rois_df, count > minSynapses)
roi_Connect_rois_df = filter(roi_Connect_rois_df, type %in% unique(roi_Connect_filt$bodytype))
```



```{r}
ggplot(roi_Connect_rois_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(cols=vars(prepost)) + #, rows = vars(hemisphere)
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)

#ggsave(paste(slctROI,"inputOutputRegions_perType.pdf",sep="_"), plot = last_plot(), device='pdf', path = "../neuprintR_analysis_plots/",
 # scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
```


```{r}
ggplot(roi_Connect_rois_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(. ~ hemisphere + prepost) +
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)

#ggsave(paste(slctROI,"inputOutputRegions_perType_perROIside.pdf",sep="_"), plot = last_plot(), device='pdf', path = "../neuprintR_analysis_plots/",
#  scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
```


### Characterize input and output regions of NO neurons *within the NO*
Regions to look at
```{r}
regs = c("NO1(L)","NO1(R)","NO2(L)","NO2(R)","NO3(L)","NO3(R)")
```

```{r message=FALSE, warning=FALSE}
# reorganize such that ROI, #pre and #post become variables
roi_Connect_intraNO_df = data.frame(bodyid = numeric(),
                              name = character(),
                              type = character(),
                              roi = character(),
                              prepost = character(),
                              count = numeric())

for (roi in as.character(colnames(roi_Connect_rois))[2:(length(colnames(roi_Connect_rois))-4)]) {
  roiname = as.character(unlist(strsplit(roi, "[.]"))[1])
  side = as.character(unlist(strsplit(roiname, "[(]"))[2])
    
  if (roiname %in% regs) {
      roi_Connect_no = data.frame(bodyid = roi_Connect_rois$bodyid,
                                  name = roi_Connect_rois$name, 
                                  type = roi_Connect_rois$type,
                                  roi = as.character(unlist(strsplit(roiname, "[(]"))[1]),
                                  hemisphere = as.character(unlist(strsplit(side, "[)]"))[1]),
                                  prepost = unlist(strsplit(roi, "[.]"))[2],
                                  count = ( as.numeric(roi_Connect_rois[[roi]]) ) ) 
      roi_Connect_intraNO_df = bind_rows(roi_Connect_intraNO_df, roi_Connect_no)
  }
}
```

```{r message=FALSE, warning=FALSE}
roi_Connect_intraNO_df = filter(roi_Connect_intraNO_df, count > minSynapses)
roi_Connect_intraNO_df = filter(roi_Connect_intraNO_df, type %in% unique(roi_Connect_filt$bodytype))
```

```{r}
ggplot(roi_Connect_intraNO_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(.~ prepost) +
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)

ggplot(roi_Connect_intraNO_df, aes(x=roi, y=type, size=count)) + 
  geom_point(aes(color=roi)) +
  facet_grid(.~ hemisphere + prepost) +
  theme_bw() + theme(axis.text.x = element_text(angle = 90))  + guides(fill=FALSE)
```



