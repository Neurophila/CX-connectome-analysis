---
title: "FB explorations"
output: html_notebook
---

Load the libraries
```{r}
#library(nat)
library(neuprintr)
library(neuprintrExtra)
library(tidyverse)
library(tidygraph)
library(ggraph)
library(gridExtra)
library(paletteer)
#source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\pathways.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\R\\supertypeUtils.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\visualizeConnectivityTables.R")
#source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\neuprintQueryUtils.R")
source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\colorCodeLookup.R")
#source("C:\\Users\\turnerevansd\\Documents\\FIBSEM\\neuprintR-notebooks\\FBNetworkVisUtils.R")
options(nat.plotengine = 'rgl')
```

Connect to neuprint
```{r}
neuprint_login()
```

Define the FB neuron types
```{r}
# Find the name of all neurons that get input in the FB
FBNronTypes = neuprint_find_neurons("FB")$bodytype %>% unique()
FBNronTypes <- FBNronTypes[which(!is.na(FBNronTypes))]
```

For each neuron type, find the number of inputs and outputs in or outside of the FB
```{r}
FBpreNpostRatios <- preNpostRatios(FBNronTypes,"FB")
ggplot(FBpreNpostRatios, aes(x=preRelative, y=postRelative,color=type)) + geom_point() + theme(legend.position="none")
```

Look at the pre and post ratios and then cut those neurons with minimal innervations
```{r}
FBpreNpostRatios <- FBpreNpostRatios[which(FBpreNpostRatios$preRelative > 0.2 | FBpreNpostRatios$postRelative > 0.15),]
ggplot(FBpreNpostRatios, aes(x=preRelative, y=postRelative,color=type)) + geom_point() + theme(legend.position="none")
```

Average the pre and post values within a given class and plot them in 2D
```{r}
FBpreNpost <- FBpreNpostRatios %>% group_by(type) %>% 
  summarize(diffMean = mean(prePostDiff),
            diffSD = sd(prePostDiff),
            relMeanPre = mean(preRelative),
            relSEMPre = sd(preRelative)/sqrt(length(preRelative)),
            relMeanPost = mean(postRelative),
            relSEMPost = sd(postRelative)/sqrt(length(postRelative)))

FBpreNpost['classification'] = 'inner'
FBpreNpost[which(FBpreNpost$diffMean > 0.05),]$classification = 'input'
FBpreNpost[which(FBpreNpost$diffMean < -0.25),]$classification = 'output'
FBpreNpost$classification <- factor(FBpreNpost$classification, levels = c('input','inner','output'))

FBpreNpost$superType = FBpreNpost$type %>% as.character() %>% supertype() %>% as.factor()

FBpreNpost$label = FBpreNpost$type %>% as.character()
FBpreNpost$label[which(grepl("FB",FBpreNpost$label))] <- ""

ggplot(FBpreNpost, aes(x=relMeanPre, y=relMeanPost)) +
  geom_abline(intercept = 0, slope = 1, color="darkgray", linetype="dashed", size=1) +
  geom_errorbar(aes(ymin=relMeanPost-relSEMPost, ymax=relMeanPost+relSEMPost,
                    color=superType),
                width=.02, position=position_dodge(0.05),alpha=0.5) +
  geom_errorbarh(aes(xmin=relMeanPre-relSEMPre, xmax=relMeanPre+relSEMPre,
                     color=superType),
                height=.02, position=position_dodge(0.05),alpha=0.5) +
  geom_point(size=8,aes(color=superType),alpha=0.5) +
  geom_text(aes(label=label,color = superType,alpha=0.5),hjust=-0.2, vjust=-0.2,size = 4,show.legend = FALSE) +
  theme_classic() + xlab('pre ratio') + ylab('post ratio') + 
  coord_fixed(ratio =1 ,xlim=c(0, 1.1),ylim=c(0, 1.1),expand=FALSE)  + 
  theme(panel.grid.major = element_line(colour = "lightgray",linetype="dashed"),text=element_text(size=18)) +
  
ggsave("FBInputsAndOutputsMean2D.svg", plot = last_plot(), device='svg', 
       path = "C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\",
       scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
```

Plot pre and post ratio differences for subsets
```{r}
for (tp in 1:4){
  if (tp == 1){
    datNow = FBpreNpost[which(grepl("PF",FBpreNpost$type)),]
    saveName = "FBInputsAndOutputs_PF.pdf"
    w = 20
    h = 15
  }
  if (tp == 2){
    datNow = FBpreNpost[which(grepl("FQ",FBpreNpost$type)),]
    saveName = "FBInputsAndOutputs_FQ.pdf"
    w = 20
    h = 15
  }
  if (tp == 3){
    datNow = FBpreNpost[which(grepl("FB",FBpreNpost$type)),]
    saveName = "FBInputsAndOutputs_FB.pdf"
    w = 40
    h = 5
  }
  if (tp == 4) {
    datNow = FBpreNpost[which(grepl("ExR",FBpreNpost$type) | grepl("OA",FBpreNpost$type)),]
    datNow <- datNow[which(datNow$type != "ExR8"),]
    saveName = "FBInputsAndOutputs_other.pdf"
    w = 20
    h = 15
  }
  
  dodge <- position_dodge(width = 0.9)
  limits <- aes(ymax = datNow$diffMean + datNow$diffSD,
                ymin = datNow$diffMean - datNow$diffSD)

  p2 <- ggplot(data = datNow, aes(x = reorder(as.factor(type), -diffMean), y = diffMean, fill = classification))
  p2 <- p2 +
    geom_hline(yintercept = 0) +
    geom_bar(stat = "identity", position = dodge) +
    geom_errorbar(limits, position = dodge, width = 0.25) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),text = element_text(size=18)) +
    xlab('neuron type') + ylab('pre ratio - post ratio')
  
  p2 <- p2 + scale_fill_manual(values = c('forestgreen','blue','red2'))
  print(p2)
  
  ggsave(saveName, plot = last_plot(), device='pdf', 
       path = "C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\",
       scale = 1.5, width = w, height = h, units ="cm", dpi = 600, limitsize = TRUE)
}
```

Create a lookup table for node locations vs. ROIs
[FB to/from outer regions]
```{r}
xyLookupFBROIs <- function(ROIs){
  ROILookup <- data.frame(ROI = ROIs, 
                          x = vector(mode = "numeric", length = length(ROIs)),
                          y = vector(mode = "numeric", length = length(ROIs)))

  
  ROILookup[which(grepl("(R)",ROIs,fixed=TRUE) &
                    grepl("in",ROIs,fixed=TRUE)),]$x <- -1
  ROILookup[which(grepl("(R)",ROIs,fixed=TRUE) &
                    grepl("out",ROIs,fixed=TRUE)),]$x <- 1
  
  regions <- ROIs %>% sapply(function(x){strsplit(x,"\\(")[[1]][1]}) %>% unique()

  ROILookup[which(grepl("FB",ROIs)),]$y <- seq(-1,1,length.out = length(which(grepl("FB",ROIs))))
  
  ROILookup[which(grepl("in",ROIs)),]$y <- seq(-1,1,length.out = length(which(grepl("in",ROIs))))
  ROILookup[which(grepl("out",ROIs)),]$y <- seq(-1,1,length.out = length(which(grepl("out",ROIs))))
  
  return(ROILookup)
  #ggplot(ROILookup,aes(x=x,y=y)) + geom_point() + scale_y_reverse() + geom_text(aes(label=ROI),hjust=1, vjust=1,size=3)
  
  }
```

Create a lookup table for node locations vs. ROIs [FB alone]
```{r}
xyLookupFBROIsIntra <- function(ROIs){
  ROILookup <- data.frame(ROI = ROIs, 
                          x = vector(mode = "numeric", length = length(ROIs)),
                          y = vector(mode = "numeric", length = length(ROIs)))

  ROILookup[which(grepl("FB",ROIs)),]$y <- 
    seq(-0.5,0.5,length.out = length(which(grepl("FB",ROIs))))
  
  return(ROILookup)
  }
```

Create a lookup table for node locations vs. ROIs [CX]
```{r}
xyLookupFBROIsCX <- function(ROIs){
  ROILookup <- data.frame(ROI = ROIs, 
                          x = vector(mode = "numeric", length = length(ROIs)),
                          y = vector(mode = "numeric", length = length(ROIs)))

  angs <- seq(-pi,pi,length.out=length(which(grepl("FB",ROIs)))+1)
  angs <- angs[1:(length(angs)-1)]
  
  ROILookup[which(grepl("in",ROIs)),]$x <- -0.5
  ROILookup[which(grepl("out",ROIs)),]$x <- 0.5

  regions <- ROIs %>% sapply(function(x){strsplit(x,"\\(")[[1]][1]}) %>% unique()

  #ROILookup[which(grepl("FB",ROIs)),]$y <- 0.5*cos(angs)
  ROILookup[which(grepl("FB",ROIs)),]$y <- seq(-0.5,0.5,length.out = length(which(grepl("FB",ROIs))))
  ROILookup[which(grepl("PB",ROIs)),]$y <- 0.5
  ROILookup[which(grepl("EB",ROIs)),]$y <- 0
  ROILookup[which(grepl("NO",ROIs)),]$y <- -0.5
  
  return(ROILookup)
  #ggplot(ROILookup,aes(x=x,y=y)) + geom_point() + scale_y_reverse() + geom_text(aes(label=ROI),hjust=1, vjust=1,size=3)
  
  }
```

Get edges from a given ROI pre and post dataframe
```{r}
getEdgesROIdf <- function(FBROIInfo,ROIsUS,ROIsDS){
  
  allROIs <- c(ROIsUS,ROIsDS) %>% unique()
  
  edges <- data.frame(to = c(),
                      from = c(),
                      weightUS = c(),
                      weightDS = c(),
                      bodyid = c(),
                      type = c())
  for (r in 1:nrow(FBROIInfo)){
    rowInfo <- FBROIInfo[r,which(!is.na(FBROIInfo[r,]))]
    ROIsNow <- colnames(rowInfo)
    ROIsNow <- ROIsNow[which(!grepl("bodyid",ROIsNow) &
                               !grepl("type",ROIsNow))]
    ROIsNow_US <- ROIsNow[which(grepl("upstream",ROIsNow))]
    ROIsNow_DS <- ROIsNow[which(grepl("downstream",ROIsNow))]
    
    for (us in 1:length(ROIsNow_US)){
      ROIUS <- strsplit(ROIsNow_US[us],".",fixed=TRUE)[[1]][1]
      if (!(ROIUS %in% ROIsUS))
        next
      for (ds in 1:length(ROIsNow_DS)){
        if (rowInfo[ROIsNow_US[us]] > synThresh &
            rowInfo[ROIsNow_DS[ds]] > synThresh){
          ROIDS <- strsplit(ROIsNow_DS[ds],".",fixed=TRUE)[[1]][1]
          if (!(ROIDS %in% ROIsDS))
            next
          edgeNow <- data.frame(from = which(ROIUS == allROIs),
                                to = which(ROIDS == allROIs),
                                weightUS = as.numeric(rowInfo[ROIsNow_US[us]]),
                                weightDS = as.numeric(rowInfo[ROIsNow_DS[ds]]),
                                bodyid = rowInfo$bodyid,
                                type = rowInfo$type)
          edges <- rbind(edges,edgeNow)
        }
      }
    }
  }
  
  return(edges)
}
```

Specify parameters for network plots
```{r}
# Synapse threshold
synThresh <- 2

# Get all FB types
FBNronTypes <- FBpreNpostRatios$type %>% unique() %>% as.character() %>% sort()

# Manually specify the ROIs to consider
ROIs = c("CRE(R)","CRE(L)","GA(R)","GA(L)","LAL(R)","LAL(L)","SNP(L)","SNP(R)",
               "FBl1","FBl2","FBl3","FBl4","FBl5","FBl6","FBl7","FBl8","FBl9",
               "EB","PB","NO","AB(R)","AB(L)")

# Assign colors to the ROIs
pcCols <- paletteer_d("Polychrome::palette36")
ROIcols <- scale_colour_manual(values = pcCols[1:length(ROIs)], limits = ROIs, guide = FALSE)
ROIcols_edge <- scale_edge_colour_manual(values = pcCols[1:length(ROIs)], limits = ROIs, guide = FALSE)

# Get the ROI info for all FB types
FBROIInfo <- neuprint_get_roiInfo(getBodyIdsForList(FBNronTypes))

# Select only the relevant ROIs and only the upstream and downstream connections
ROISelection <- colnames(FBROIInfo)
ROINames <- sapply(ROIs,function(x)
  {ROISelection[(grepl(paste0(x,"."),ROISelection,fixed=TRUE) &
                   (grepl("upstream",ROISelection) |
                      grepl("downstream",ROISelection)))]}) 
ROINames <- ROINames %>% unlist() %>% as.character()
FBROIInfo <- FBROIInfo %>% select(c("bodyid",ROINames)) %>% mutate(type = neuprint_get_meta(bodyid)$type)
```

Plot the number of neurons that run between different ROIs
[Intra FB]
```{r}
# Get the table of nodes (types)
ROIs_Intra <- ROIs[which(grepl("FB",ROIs))]
nodes_Intra <- xyLookupFBROIsIntra(ROIs_Intra)
edges_Intra <- getEdgesROIdf(FBROIInfo,ROIs_Intra,ROIs_Intra)

# Pull out the number of types between each ROI
edges_Intra_numTypes <- edges_Intra %>% group_by(to,from) %>% 
  summarize(numTypes = length(unique(type)),
            numUSsyns = sum(weightUS),
            numDSsyns = sum(weightDS))
edges_Intra_numTypes$ROI.from <- sapply(edges_Intra_numTypes$from, function(x) nodes_Intra$ROI[x])
edges_Intra_numTypes$ROI.to <- sapply(edges_Intra_numTypes$to, function(x) nodes_Intra$ROI[x])

graph_Intra <- tbl_graph(nodes_Intra,edges_Intra_numTypes)

gg_Intra <-
  ggraph(graph_Intra,layout="manual",x=nodes_Intra$x,y=nodes_Intra$y) + 
  geom_edge_arc(aes(width=numUSsyns,color=ROI.from),alpha=0.5,
                     strength=1,
                     arrow = arrow(length = unit(0.5, "cm")),
                     end_cap = circle(1, 'cm')) + 
  geom_edge_loop(aes(direction=45,span=90,width=numUSsyns,strength=0.1,color=ROI.from),alpha=0.5) +
  ROIcols_edge +
  geom_node_point(aes(color=ROI),size=8) + 
  ROIcols +
  geom_node_text(aes(label=ROI),angle=40,size=6) +
  theme_classic() + theme(legend.text=element_text(size=12),legend.title=element_text(size=12),
                          axis.line=element_blank(),axis.text.x=element_blank(),
                          axis.text.y=element_blank(),axis.ticks=element_blank(),
                          axis.title.x=element_blank(),axis.title.y=element_blank(),
                          plot.title = element_text(hjust = 0.5, size = 24)) + 
  coord_fixed(ratio = 1,clip="off") + ggtitle('all intra FB connections')
```

Plot the number of neurons that run between different ROIs
[Intra FB - just Deltas]
```{r}
# Get the table of nodes (types)
edges_Intra_Deltas <- edges_Intra %>% filter(grepl("Delta0",type))

# Pull out the number of types between each ROI
edges_Intra_Deltas_numTypes <- edges_Intra_Deltas %>% group_by(to,from) %>% 
  summarize(numTypes = length(unique(type)),
            numUSsyns = sum(weightUS),
            numDSsyns = sum(weightDS))
edges_Intra_Deltas_numTypes$ROI.from <- sapply(edges_Intra_Deltas_numTypes$from, function(x) nodes_Intra$ROI[x])
edges_Intra_Deltas_numTypes$ROI.to <- sapply(edges_Intra_Deltas_numTypes$to, function(x) nodes_Intra$ROI[x])

graph_Intra_Deltas <- tbl_graph(nodes_Intra,edges_Intra_Deltas_numTypes)

gg_Intra_Deltas <-
  ggraph(graph_Intra_Deltas,layout="manual",x=nodes_Intra$x,y=nodes_Intra$y) + 
  geom_edge_arc(aes(width=numUSsyns,color=ROI.from),alpha=0.5,
                     strength=1,
                     arrow = arrow(length = unit(0.5, "cm")),
                     end_cap = circle(1, 'cm')) + 
  #geom_edge_loop(aes(direction=45,span=90,width=numUSsyns,strength=0.1,color=ROI.from),alpha=0.5) +
  ROIcols_edge +
  geom_node_point(aes(color=ROI),size=8) + 
  ROIcols +
  geom_node_text(aes(label=ROI),angle=40,size=6) +
  theme_classic() + theme(legend.text=element_text(size=12),legend.title=element_text(size=12),
                          axis.line=element_blank(),axis.text.x=element_blank(),
                          axis.text.y=element_blank(),axis.ticks=element_blank(),
                          axis.title.x=element_blank(),axis.title.y=element_blank(),
                          plot.title = element_text(hjust = 0.5, size=24)) + 
  coord_fixed(ratio = 1,clip="off") + ggtitle('Delta0s, intra layer connections removed')
```


Plot the number of neurons that run between different ROIs 
[From FB to PB, EB, and NO (and vice versa)]
```{r}
# Get the table of nodes (types)
ROIs_CX <- ROIs[which(grepl("FB",ROIs) | (ROIs %in% c("PB","EB","NO")))]
edges_CX <- getEdgesROIdf(FBROIInfo,ROIs_CX,ROIs_CX)
edges_CX <- edges_CX %>% filter(!(
  (to %in% which(grepl("FB",nodes_CX$ROI))) &
    (from %in% which(grepl("FB",nodes_CX$ROI)))))

colVals <- pcCols[1:length(ROIs)]
colVals <- c(colVals[which(ROIs %in% ROIs_CX)],
             colVals[which(ROIs %in% ROIs_CX[which(!grepl("FB",ROIs_CX))])])

ROIs_CX[which(!grepl("FB",ROIs_CX))] <- ROIs_CX[which(!grepl("FB",ROIs_CX))] %>% paste0("_in")
ROIs_CX <- c(ROIs_CX,
                 gsub("in","out",ROIs_CX[which(!grepl("FB",ROIs_CX))]))
nodes_CX <- xyLookupFBROIsCX(ROIs_CX)
edges_CX <- edges_CX %>% mutate(ROI.to = nodes_CX$ROI[to],
                                        ROI.from = nodes_CX$ROI[from])
edges_CX$ROI.to <- gsub("in","out",edges_CX$ROI.to)
edges_CX$to <- lapply(edges_CX$ROI.to, function(x){which(x == as.character(nodes_CX$ROI))}) %>% unlist()

ROIcols <- scale_colour_manual(values = colVals , limits = ROIs_CX, guide = FALSE)
ROIcols_edge <- scale_edge_colour_manual(values = colVals , limits = ROIs_CX, guide = FALSE)

# Pull out the number of types between each ROI
edges_CX_numTypes <- edges_CX %>% group_by(to,from) %>% 
  summarize(numTypes = length(unique(type)),
            numUSsyns = sum(weightUS),
            numDSsyns = sum(weightDS))
edges_CX_numTypes$ROI.from <- sapply(edges_CX_numTypes$from, function(x) nodes_CX$ROI[x])
edges_CX_numTypes$ROI.to <- sapply(edges_CX_numTypes$to, function(x) nodes_CX$ROI[x])

graph_CX <- tbl_graph(nodes_CX,
                      filter(edges_CX_numTypes,(grepl("FB",ROI.from) | grepl("FB",ROI.to))))

gg_CX <-
  ggraph(graph_CX,layout="manual",x=nodes_CX$x,y=nodes_CX$y) + 
  geom_edge_arc(aes(width=numUSsyns,color=ROI.from),alpha=0.5,
                     strength=0.25,
                     arrow = arrow(length = unit(0.5, "cm")),
                     end_cap = circle(1, 'cm')) + 
  geom_edge_loop(aes(direction=45,span=90,width=numUSsyns,strength=0.1,color=ROI.from),alpha=0.5) +
  ROIcols_edge +
  geom_node_point(aes(color=ROI),size=8) + 
  ROIcols +
  geom_node_text(aes(label=ROI),angle=40,size=6) +
  theme_classic() + theme(legend.text=element_text(size=12),legend.title=element_text(size=12),
                          axis.line=element_blank(),axis.text.x=element_blank(),
                          axis.text.y=element_blank(),axis.ticks=element_blank(),
                          axis.title.x=element_blank(),axis.title.y=element_blank(),) + 
  coord_fixed(ratio = 1,clip="off")
```

Plot the number of neurons that run between different ROIs 
[From outside CX in to layers (L) and vice versa (L) for (R) ROIs]
```{r}
# Get the table of nodes (types)
ROIs_InNOut <- ROIs[which(!(ROIs %in% c("EB","PB","NO")))]
ROIs_InNOut <- ROIs_InNOut[which(grepl("FB",ROIs_InNOut) |
                                   grepl("(R)",ROIs_InNOut,fixed=TRUE))]
edges_InNOut <- getEdgesROIdf(FBROIInfo,ROIs_InNOut,ROIs_InNOut)

colVals <- pcCols[1:length(ROIs)]
colVals <- c(colVals[which(ROIs %in% ROIs_InNOut)],
             colVals[which(ROIs %in% ROIs_InNOut[which(!grepl("FB",ROIs_InNOut))])])

ROIs_InNOut[which(!grepl("FB",ROIs_InNOut))] <- ROIs_InNOut[which(!grepl("FB",ROIs_InNOut))] %>% paste0("_in")
ROIs_InNOut <- c(ROIs_InNOut,
                 gsub("in","out",ROIs_InNOut[which(!grepl("FB",ROIs_InNOut))]))
nodes_InNOut <- xyLookupFBROIs(ROIs_InNOut)
edges_InNOut <- edges_InNOut %>% mutate(ROI.to = nodes_InNOut$ROI[to],
                                        ROI.from = nodes_InNOut$ROI[from])
edges_InNOut$ROI.to <- gsub("in","out",edges_InNOut$ROI.to)
edges_InNOut$to <- sapply(edges_InNOut$ROI.to, function(x){which(x == nodes_InNOut$ROI)})

ROIcols <- scale_colour_manual(values = colVals , limits = ROIs_InNOut, guide = FALSE)
ROIcols_edge <- scale_edge_colour_manual(values = colVals , limits = ROIs_InNOut, guide = FALSE)

# Pull out the number of types between each ROI
edges_InNOut_numTypes <- edges_InNOut %>% group_by(to,from) %>% 
  summarize(numTypes = length(unique(type)),
            numUSsyns = sum(weightUS),
            numDSsyns = sum(weightDS))
edges_InNOut_numTypes$ROI.from <- sapply(edges_InNOut_numTypes$from, function(x) nodes_InNOut$ROI[x])
edges_InNOut_numTypes$ROI.to <- sapply(edges_InNOut_numTypes$to, function(x) nodes_InNOut$ROI[x])

# Plot the network
graph_InNOut <- tbl_graph(nodes_InNOut,
                   filter(edges_InNOut_numTypes,(
                     (grepl("FB",ROI.from) | grepl("FB",ROI.to)) &
                       !(grepl("FB",ROI.from) & grepl("FB",ROI.to)))))

gg_InNOut <-
  ggraph(graph_InNOut,layout="manual",x=nodes_InNOut$x,y=nodes_InNOut$y) + 
  geom_edge_diagonal(aes(width=numUSsyns,color=ROI.from),alpha=0.5,
                     strength=1,
                     arrow = arrow(length = unit(0.5, "cm")),
                     end_cap = circle(1, 'cm')) + 
  geom_edge_loop(aes(direction=45,span=90,width=numUSsyns,strength=0.1,color=ROI.from),alpha=0.5) +
  ROIcols_edge +
  geom_node_point(aes(color=ROI),size=8) + 
  ROIcols +
  geom_node_text(aes(label=ROI),angle=40,size=6) +
  theme_classic() + theme(legend.text=element_text(size=12),legend.title=element_text(size=12),
                          axis.line=element_blank(),axis.text.x=element_blank(),
                          axis.text.y=element_blank(),axis.ticks=element_blank(),
                          axis.title.x=element_blank(),axis.title.y=element_blank(),) + 
  coord_fixed(ratio = 1,clip="off")

```

Plot the ROI connectivity graphs
```{r}
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\FBROIConnectivity.pdf", width = 40, height = 10)
print(grid.arrange(gg_InNOut,gg_Intra,gg_Intra_Deltas,gg_CX,nrow=1))
dev.off()
```

############################################################
Look at where the PFLs get their synapses
############################################################

```{r}
# Pull the PFL ROI info
PFLROIInfo <- neuprint_get_roiInfo(getBodyIdsForList("PFL.*"))

# Restrict to upstream PB connections
PFLROIInfo_PB <- PFLROIInfo[,which((grepl("PB",colnames(PFLROIInfo)) & grepl("upstream",colnames(PFLROIInfo))) | grepl("bodyid",colnames(PFLROIInfo)))]
PFLROIInfo_PB <- PFLROIInfo_PB %>% mutate(type = neuprint_get_meta(bodyid)$type,
                                          name = neuprint_get_meta(bodyid)$name)
PBDatToPlot <- PFLROIInfo_PB[,which(grepl("(",colnames(PFLROIInfo_PB),fixed=TRUE) |
                                      grepl("name",colnames(PFLROIInfo_PB)))]
# Rename the columns by the glomeruli
PBGloms <- colnames(PBDatToPlot) %>% 
  sapply(function(x){strsplit(x,"(",fixed=TRUE)[[1]][2]}) %>% as.character() %>%
  sapply(function(x){strsplit(x,")",fixed=TRUE)[[1]][1]}) %>% as.character()
PBGloms <- PBGloms %>% head(length(PBGloms)-1)
colnames(PBDatToPlot) <- c(PBGloms,"name")

# Melt the data into one dataframe
library(reshape2)
PBDatToPlot <- melt(PBDatToPlot,id="name")
colnames(PBDatToPlot)[2] <- "PBglom"
colnames(PBDatToPlot)[3] <- "upstreamSynapses"
PBDatToPlot$PBglom <- factor(PBDatToPlot$PBglom, 
                             levels = sort(as.character(unique(PBDatToPlot$PBglom))))
PBDatToPlot <- PBDatToPlot[which(!is.na(PBDatToPlot$upstreamSynapses)),]

# Plot it
g <- ggplot(PBDatToPlot) + geom_tile(aes(x=PBglom,y=name,fill=upstreamSynapses)) +
    scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                         midpoint =0.5*max(PBDatToPlot$upstreamSynapses),
                         limits=c(0,max(PBDatToPlot$upstreamSynapses))) + 
  geom_hline(yintercept = 14.5) + geom_hline(yintercept = 24.5)

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\PB\\PFLGlomConnectivity.pdf", width = 10, height = 10)
print(g)
dev.off()
```

############################################################
Look at connectivity matrices between Delta6s and FX/PB-FB-XX neurons, rotate to align by column
############################################################
```{r}
D6types <- getBodyIdsForList("Delta6.*")$type %>% unique()
coltypes <- getBodyIdsForList(c("PF.*","FC.*","FS.*","FR.*"))$type %>% unique()

prePlots <- list()
pltNow <- 1
for (d6t in 1:length(D6types)){
  for (colt in 1:length(coltypes)){
    D6ids <- getBodyIdsForList(paste0(D6types[d6t],".*"))$bodyid
    colids <- getBodyIdsForList(paste0(coltypes[colt],".*"))$bodyid
    
    D6CTPre <- getConnectionTable(D6ids,"PRE","FB") %>% filter(from %in% colids)
    
    if ((length(unique(D6CTPre$from)) < 0.5*length(colids)) |
        (length(unique(D6CTPre$to)) < 0.5*length(D6ids)))
      next
    
    D6CTPre$nameid.from = paste(as.character(D6CTPre$name.from), as.character(D6CTPre$from), sep = "_")
    D6CTPre$nameid.to = paste(as.character(D6CTPre$name.to), as.character(D6CTPre$to), sep = "_")
    nameids <- unique(D6CTPre$nameid.from)
    idOrder = c()
    for (cl in 1:9) {
      idOrder <-  append(idOrder,sort(nameids[which(grepl(paste0('_C',cl,'_'),nameids))]))
    }
    D6CTPre$nameid.from <- factor(D6CTPre$nameid.from,levels=idOrder)
    
    cmax = max(D6CTPre$weightRelative)
    prePlot = ggplot(D6CTPre) + 
        theme_classic() + theme(axis.text.x = element_text(angle = 90)) +
        scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                             midpoint =0.5*cmax, limits=c(0,cmax)) +
      geom_tile(aes(x=as.factor(nameid.to),y=as.factor(nameid.from),fill=weightRelative))
    prePlots[[pltNow]] <- prePlot
    pltNow <- pltNow + 1
    
  }
}
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta6Pre.pdf", width = 100, height = 100)
print(grid.arrange(grobs=prePlots))
dev.off()


postPlots <- list()
pltNow <- 1
for (d6t in 1:length(D6types)){
  for (colt in 1:length(coltypes)){
    D6ids <- getBodyIdsForList(paste0(D6types[d6t],".*"))$bodyid
    colids <- getBodyIdsForList(paste0(coltypes[colt],".*"))$bodyid
    
    D6CTPost <- getConnectionTable(D6ids,"POST","FB") %>% filter(to %in% colids)
    
    if ((length(unique(D6CTPost$from)) < 0.5*length(D6ids)) |
        (length(unique(D6CTPost$to)) < 0.5*length(colids)))
      next
    
    D6CTPost$nameid.from = paste(as.character(D6CTPost$name.from), as.character(D6CTPost$from), sep = "_")
    D6CTPost$nameid.to = paste(as.character(D6CTPost$name.to), as.character(D6CTPost$to), sep = "_")
    nameids <- unique(D6CTPost$nameid.to)
    idOrder = c()
    for (cl in 1:9) {
      idOrder <-  append(idOrder,sort(nameids[which(grepl(paste0('_C',cl,'_'),nameids))]))
    }
    D6CTPost$nameid.to <- factor(D6CTPost$nameid.to,levels=idOrder)
    
    cmax = max(D6CTPost$weightRelative)
    postPlot = ggplot(D6CTPost) + 
        theme_classic() + theme(axis.text.x = element_text(angle = 90)) +
        scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                             midpoint =0.5*cmax, limits=c(0,cmax)) +
      geom_tile(aes(x=as.factor(nameid.to),y=as.factor(nameid.from),fill=weightRelative))
    postPlots[[pltNow]] <- postPlot
    pltNow <- pltNow + 1
    
  }
}
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\Deltas\\Delta6Post.pdf", width = 100, height = 100)
print(grid.arrange(grobs=postPlots))
dev.off()

```

############################################################
Try clustering, graph analyses on FB network
############################################################

Get the connection tables
```{r}

FBt_Pre = getConnectionTable(getBodyIdsForList(c("FB")),"PRE","FB")
FBt_To_Col_Pre <- FBt_Pre %>% filter(supertype.from2 != "FBt")

FBt_Post = getConnectionTable(getBodyIdsForList(c("FB")),"POST","FB")
FBt_To_FBt_Post <- FBt_Post %>% filter(supertype.to2 == "FBt")
FBt_To_Col_Post <- FBt_Post %>% filter(supertype.to2 != "FBt")


FBt_To_FBt_Post_T2T <- getTypeToTypeTable(FBt_To_FBt_Post)
conmatPlot_FBt <- plotConnectivityMatrix(FBt_To_FBt_Post_T2T,byGroup="type")
print(conmatPlot_FBt)

FBt_To_Col_Pre_T2T <- getTypeToTypeTable(FBt_To_Col_Pre)
conmatPlot_Col_Pre <- plotConnectivityMatrix(FBt_To_Col_Pre_T2T,byGroup="type")
print(conmatPlot_Col_Pre)

FBt_To_Col_Post_T2T <- getTypeToTypeTable(FBt_To_Col_Post)
conmatPlot_Col_Post <- plotConnectivityMatrix(FBt_To_Col_Post_T2T,byGroup="type")
print(conmatPlot_Col_Post)

cmax = max(FBt_To_Col_Pre_T2T$weightRelative)
conmatPlot_Col_Post_Flip <- ggplot(FBt_To_Col_Pre_T2T) + 
    theme_classic() + theme(axis.text.x = element_text(angle = 90)) +
    scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                         midpoint =0.5*cmax, limits=c(0,cmax)) +
  geom_tile(aes(type.from,type.to,fill=weightRelative))
print(conmatPlot_Col_Post_Flip)

```

Format the FBt to columnar connections data frame and perform hierarchical clustering
```{r}
hc_Pre <- hierClustT2T(FBt_To_Col_Post_T2T,"PRE")
hc_Post <- hierClustT2T(FBt_To_Col_Post_T2T,"POST")

pFB_Pre <- dendPlot(hc_Pre,TRUE)
pFB_Post <- dendPlot(hc_Post,FALSE)

clustOrder_FBt <- hc_Pre$labels[hc_Pre$order]
clustOrder_Col <- hc_Post$labels[hc_Post$order]

FBt_To_Col_Post_T2T$type.from <- factor(FBt_To_Col_Post_T2T$type.from,levels=clustOrder_FBt)
FBt_To_Col_Post_T2T$type.to <- factor(FBt_To_Col_Post_T2T$type.to,levels=clustOrder_Col)
conmatPlot_Clust <- plotConnectivityMatrix(FBt_To_Col_Post_T2T,byGroup="type")
print(conmatPlot_Clust)
```

Put them all on a plot
```{r}
conmatPlot_FBt <- conmatPlot_FBt + 
  theme(axis.text.x = element_text(size=2),
                axis.text.y = element_text(size=2)) +
  ggtitle("FBt to FBt")

conmatPlot_Clust <- conmatPlot_Clust + 
  theme(axis.text.x = element_text(size=4),
                axis.text.y = element_text(size=2)) +
  ggtitle("FBt to FB columnar - clustered") + guides(fill=FALSE)
pFB_Pre <- pFB_Pre +
  theme(axis.text.y = element_text(size=2)) +
  guides(color=FALSE)
pFB_Post <- pFB_Post +
  theme(axis.text.x = element_text(size=4)) +
  guides(color=FALSE)


pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\FBtClustering.pdf", width = 10, height = 10)
print(grid.arrange(grobs = list(conmatPlot_FBt,pFB_Post,pFB_Pre,conmatPlot_Clust),
                   layout_matrix = rbind(c(2,1),c(4,3))))
dev.off()
```

Try the above for columnar to columnar connections
```{r}
nrons = c("PF","FC","FR","FS","Delta0","Delta6")
Col_Post = getConnectionTable(getBodyIdsForList(c(nrons)),"POST","FB")

Col_To_Col <- Col_Post %>% filter(supertype.to3 == "FB Columnar"  | supertype.to3 == "FB Interneuron" | supertype.to3 == "FB Output")

Col_To_Col_T2T <- getTypeToTypeTable(Col_To_Col)
conmatPlot <- plotConnectivityMatrix(Col_To_Col_T2T,byGroup="type")
print(conmatPlot)
```

```{r}

hc_Pre <- hierClustT2T(Col_To_Col_T2T,"PRE")
hc_Post <- hierClustT2T(Col_To_Col_T2T,"POST")

pFB_Pre <- dendPlot(hc_Pre,TRUE)
pFB_Post <- dendPlot(hc_Post,FALSE)

pFB_Pre <- pFB_Pre +
  theme(axis.text.y = element_text(size=2)) +
  guides(color=FALSE)
pFB_Post <- pFB_Post +
  theme(axis.text.x = element_text(size=4)) +
  guides(color=FALSE)

clustOrder_Pre <- hc_Pre$labels[hc_Pre$order]
clustOrder_Post <- hc_Post$labels[hc_Post$order]

Col_To_Col_T2T$type.to <- factor(Col_To_Col_T2T$type.to,levels=clustOrder_Post)
Col_To_Col_T2T$type.from <- factor(Col_To_Col_T2T$type.from,levels=clustOrder_Pre)
conmatPlot <- plotConnectivityMatrix(Col_To_Col_T2T,byGroup="type")
conmatPlot <- conmatPlot + 
  theme(axis.text.x = element_text(size=6),
        axis.text.y = element_text(size=6)) +
  guides(fill=FALSE)

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\ColClustering.pdf", width = 10, height = 10)
print(grid.arrange(grobs = list(pFB_Post,pFB_Pre,conmatPlot),
                   layout_matrix = rbind(c(1,NA),c(3,2))))
dev.off()
```

Cluster all FB types
```{r}
nrons = c("PF","FC","FR","FS","Delta0","Delta6","FB")
FB_Post = getConnectionTable(getBodyIdsForList(c(nrons)),"POST","FB")
FB_T2T <- getTypeToTypeTable(FB_Post)

# Get the dendrograms
hc_Post <- hierClustT2T(FB_T2T,"POST")
hc_Pre <- hierClustT2T(FB_T2T,"PRE")

# Plot the obtained dendrogram
pFB_Post <- dendPlot(hc_Post,FALSE)
pFB_Pre <- dendPlot(hc_Pre,TRUE)
pFB_Post <- pFB_Post +
  ggtitle("post synaptic clustering")
pFB_Pre <- pFB_Pre +
  ggtitle("pre synaptic clustering")

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\AllFBClustering_Pre.pdf", width = 10, height = 10)
print(pFB_Pre)
dev.off()

pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\AllFBClustering_Post.pdf", width = 10, height = 10)
print(pFB_Post)
dev.off()
```

Function to hierarchically cluster pre or post data from a connection table
```{r}
hierClustT2T <- function(T2T,prepost){
  library(reshape2)
  
  # Select only the relevant columns
  Data4Clust <- T2T %>% select(type.from,type.to,weightRelative)
  
  # Format the data
  if (prepost == "POST"){
    Data4Clust <- dcast(Data4Clust,type.to~type.from)
  } else {
    Data4Clust <- dcast(Data4Clust,type.from~type.to)
  }
  Data4Clust[is.na(Data4Clust)] <- 0
  if (prepost == "POST"){
    rownames(Data4Clust) <- Data4Clust$type.to
  } else {
    rownames(Data4Clust) <- Data4Clust$type.from
  }
  Data4Clust <- Data4Clust %>% select(tail(colnames(Data4Clust),ncol(Data4Clust)-1))
  Data4Clust <- scale(Data4Clust)
  
  # Calculate the dissimilarity matrix
  d <- dist(Data4Clust, method = "euclidean")
  
  # Perform hierarchical clustering
  hc <- hclust(d, method = "ward.D2" )
  
  # Return the cluster
  return(hc)
}
```

Function to plot a dendrogram
```{r}
dendPlot <- function(hc,rotate){
  library(ggdendro)
  
  # Pull of the data
  dend <- as.dendrogram(hc)
  dend_data <- dendro_data(dend, type = "rectangle")

  # Add a supertype category
  HClabels <- dend_data$labels
  HClabels$supertype <- HClabels$label %>% as.character() %>% supertype() %>% as.factor()

  p <- ggplot(dend_data$segments)
  if (rotate){
    p <- p + geom_segment(aes(x = y, y = x, xend = yend, yend = xend)) +
    geom_text(data = HClabels, aes(y, x, label = label,color=supertype),
              hjust = 1, size = 1)
  } else {
    p <- p + geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
    geom_text(data = HClabels, aes(x, y, label = label,color=supertype),
              hjust = 1, angle = 90, size = 1)
  }
  p <- p + theme_classic() +
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.line=element_blank())
  
  return(p)
}
```

Create an igraph network of the FB connections
First, get the type to type connectivity table
```{r}
nrons = neuprint_bodies_in_ROI("FB") %>% mutate(type = neuprint_get_meta(bodyid)$type) %>% filter(grepl("PF|FC|FR|FS|vDelta|hDelta|FB",type)) %>% select(type) %>% unique() %>% unlist() %>% as.character()
FB_Post = getConnectionTable(getTypesTable(nrons),"POST","FB")
FB_T2T <- getTypeToTypeTable(FB_Post)
```

Now, convert it into an igraph function
```{r}
library(igraph)
FBNodes <- c(FB_T2T$type.to,FB_T2T$type.from) %>% unique() %>% as.data.frame()
colnames(FBNodes) <- "nodes"
FBNodes$supertype <- FBNodes$nodes %>% as.character() %>% supertype()
sTs <- unique(FBNodes$supertype)
pcCols <- paletteer_d("Polychrome::palette36")
sTsCols <- c(pcCols[35],pcCols[32],pcCols[2],pcCols[8],
             pcCols[24],pcCols[24],pcCols[17],pcCols[9],
             pcCols[3],pcCols[1],pcCols[7],pcCols[24],
             pcCols[26],pcCols[24],pcCols[24],pcCols[24],
             pcCols[24])

FBEdges <- FB_T2T %>% mutate(from = type.from, to = type.to, weight = weightRelative) %>%
  select(from,to,weight)
FBEdges$supertype.from <- FBEdges$from %>% as.character() %>% supertype()

g <- graph_from_data_frame(FBEdges, directed = TRUE, vertices = FBNodes)


E(g)$weight <- FBEdges$weight
E(g)$color <- sapply(FBEdges$supertype.from, function(st){sTsCols[which(st==sTs)]})
V(g)$label.cex = 0.6
V(g)$label.color = "black"
V(g)$color = sapply(FBNodes$supertype, function(st){sTsCols[which(st==sTs)]})
co <- layout_with_lgl(g)
pdf("C:\\Users\\turnerevansd\\Dropbox (HHMI)\\FIBSEM CX Paper Jan 2020\\Figures\\FB\\FBNetwork.pdf")
plot(g, layout = co, vertex.size=5, edge.arrow.size=0.1)
dev.off()

cfg <- cluster_fast_greedy(as.undirected(g))
plot(cfg, as.undirected(g), vertex.size=10)
```

Could also try t-SNE projection