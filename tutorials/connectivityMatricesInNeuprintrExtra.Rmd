---
title: "neuprintrExtra: connectivity matrices etc."
output: html_notebook
---

```{r}
library(neuprintrExtra)
library(ggplot2)
library(dplyr)
```

Starting from a favorite example:
```{r}
PFLs <- neuronBag(getTypesTable(c("PFL1","PFL2","PFL3")),slctROI=c("FB","LAL(-GA)(R)"))
```

## Plotting a connectivity table
The base interface is very similar to `plotConnectivityMatrix`
```{r}
plotConnectivity(PFLs$outputs,grouping="type",connectionMeasure = "weightRelative")
```
Grouping can be anything that has columns postfixed with `.to` and `.from`, or "neuron", or "bodyid" -- assuming there's only one value per to/from combo and that there's only one ROI (which can also be selected with the `slctROI` argument). For example, looking at inputs in the raw table:

```{r}
plotConnectivity(PFLs$inputs_raw,grouping="neuron",connectionMeasure = "weightRelative",slctROI="FB")
```

For those kind of plots, you might want to replace the labels with something more meaningful. You can specify it in the `replacementLabels` argument. Again, it takes any name that has .to and .from columns in the data.frame (so you can create custom columns to get custom names if needed)
```{r}
plotConnectivity(PFLs$inputs_raw,grouping="neuron",connectionMeasure = "weightRelative",slctROI="FB",replacementLabels = "name")
```
One might want to change the ordering also. One way is to do it true clustering (see below) but it can also be controlled manually using the `orderIn` and `orderOut` arguments. Those take a vector to be used as factor levels for the x/y axis (in that case vectors of bodyids). For example, for doing it by lexical order of the names (here just for the outputs):
```{r}
idsOut <- unique(PFLs$inputs_raw$to)
sortingOrder <- sort(PFLs$inputs_raw$name.to[match(idsOut,PFLs$inputs_raw$to)],index.return=T)$ix
sortedIds <- idsOut[sortingOrder]
sortedIds
```
This can be used then:
```{r}
plotConnectivity(PFLs$inputs_raw,grouping="neuron",connectionMeasure = "weightRelative",slctROI="FB",replacementLabels = "name",orderOut=sortedIds)
```
You can also facet, on any column in the data.frame. Building on:
```{r}
plotConnectivity(PFLs$inputs_raw,grouping="neuron",connectionMeasure = "weightRelative",slctROI="FB",replacementLabels = "name",facetInputs="supertype2.from")
```
### Appearance tweaks
Going back to the same plot, but by type. The appearance can be controlled via the `theme` argument, and you can always use the theme function to further refine. Also, there's a `legendName` argument to change the name appearing in the legend. 
```{r}
plotConnectivity(PFLs$inputs,grouping="type",connectionMeasure = "weightRelative",slctROI="FB",facetInputs="supertype2.from",facetOutputs="type.to",theme=theme_classic(),legendName = "Nice metric") + theme(panel.background=element_rect(fill="gray95"))
```


## Clustering a connection table

### From a table
This is done via the `connectivityCluster` function, which creates an object of the same name. A `connectivityCluster` object is just a list with fields:
- `inputsTable` : table of inputs to the neurons to cluster. Will be NULL if clustering on outputs
- `outputsTable`: table of inputs to the neurons to cluster. Will be NULL if clustering on inputs 
- `names` : the names of the neurons clustered
- `distance` : the distance object obtained
- `hc` the result of the clustering 
- `grouping` what is being clustered (neurons, types, etc)
For example, to cluster the individual PFLs on their inputs in the FB
```{r}
PFLFromInputs <- connectivityCluster(inputsTable=PFLs$inputs_raw,ROIs="FB",grouping="neuron")
```

There are then 2 plotting methods:
-`plotClusters` to just plot the distance matrix (replacementLabels works the same as for plotConnectivity):
```{r}
plotClusters(PFLFromInputs,replacementLabels = "name")
```
To questionable results, one can also color the axis per cluster by passing an argument to `cutree` inside the function (and setting `colorAxis` to TRUE):
```{r}
plotClusters(PFLFromInputs,colorAxis = T,h=0.8,replacementLabels = "name")
```
 
Usually things will be run on type to type tables (although on bigger ones), as in :
```{r}
PFLFromInputsTypes <- connectivityCluster(inputsTable=PFLs$inputs,ROIs="FB",grouping="type")
plotClusters(PFLFromInputsTypes)
```
More interestingly, there's also a `plotConnectivity` method for those objects, that automatically orders the relevant axis by the defined clusters:
```{r}
plotConnectivity(PFLFromInputsTypes)
```
Of course you might still want to order the other axis, which you can do using the "orderIn"/"orderOut" argument: here for example running connectivityClustering for the other side of the matrix. You can also directly give another connectivityCluster object for that argument.
```{r}
clusterPFLInputs <- connectivityCluster(outputsTable=PFLs$inputs,grouping="type",ROIs = "FB")

plotConnectivity(PFLFromInputsTypes,orderIn=clusterPFLInputs)
```
Notice that connectivityCluster does not return "clusters" per se, you need to run `cutree` to get those. There's also a shortcut to add them as a column to the table in the connectivityCluster: `setClusters` or add clusters from another object to the partner neurons with `addClusters`
```{r}
inputsCl <- cutree(clusterPFLInputs$hc,h=0.8)

PFLFromInputsTypes <- setClusters(PFLFromInputsTypes,h=0.8)  # Adds cluster.to to inputsTable 
PFLFromInputsTypes <- addClusters(PFLFromInputsTypes,clusterPFLInputs,h=0.8) #Adds cluster.from to inputsTable
```

```{r}
plotConnectivity(PFLFromInputsTypes,orderIn=orderPFLIn,facetInputs="cluster.from",facetOutputs="cluster.to")+theme(panel.border = element_rect(colour = "grey", fill = NA, size=0.3))
```


### From a neuronBag
 `connectivityCluster` can also be built from a neuronBag, with the `clusterBag` function. In that case, you need to specify if you want to cluster on inputs, outputs, or both, and you always cluster the neurons "in the middle":
 
```{r}
bagCluster <- clusterBag(PFLs,clusterOn="both",ROIs = "FB")
```
 
```{r}
plotConnectivity(bagCluster)
```

All those functions are somewhat documented. Suggestions welcome!

