---
title: "Outputs"
output: html_notebook
---

```{r message=FALSE, warning=FALSE}
library(neuprintr)
library(tidyverse)
library(cowplot)
library(patchwork)
library(neuprintrExtra)
library(nat)
library(Cairo)
library(ggdendro)
library(paletteer)
```

```{r message=FALSE}
source("../synapseDistsTools.R")
source("outputFunctions.R")
source("../R/paperTheme.R")
outputsFolder <- "~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/"
```


## Building the outputs neuron bag
Find the output channels in the CX
```{r}
roiH <- getRoiTree()
CXtypes <- supertype(read_csv("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/CX-cell-types060920") %>% rename(databaseType=n.type))
CXNeurons <- getTypesTable(CXtypes$databaseType)
CXNeurons <- cxRetyping(CXNeurons,postfix="raw")
CXNeurons <- supertype(CXNeurons)

outsideRegions <- unique(selectRoiSet(exceptions=sapply(as.character(unique(roiH$level1[grepl(roiH$level1,pattern="(R)")])),function(i) return(1),USE.NAMES = TRUE,simplify=FALSE),
                                     exceptionLevelMatch = 1)$roi[roiH$level1!="CX" & roiH$side4!="Left"])

CXPerROI <- getROISummary(CXNeurons,threshold=0)

CXPerROIRedux <- filter(CXPerROI,roi %in% outputRegions) %>% group_by(type,databaseType,n,supertype1,supertype2,supertype3) %>%
   summarize(upstream=sum(upstream),
             downstream=sum(downstream),
             fullWeight=sum(fullWeight),
             downstreamRatio=downstream/fullWeight) %>%
   ungroup() %>% distinct()
CXOutsideTypes <- filter(CXPerROIRedux,fullWeight>20)
CXPotentialOutputs <- filter(CXPerROIRedux,downstream>20 & downstreamRatio>0.1)
CXPotentialInputs <- filter(CXPerROIRedux,upstream>20 & downstreamRatio<=0.1)
CXPotentialOutputNeurons <- filter(CXNeurons,type %in% CXPotentialOutputs$type)
CXPotentialInputNeurons <- filter(CXNeurons,type %in% CXPotentialInputs$type)
CXOutsideNeurons <- filter(CXNeurons,type %in% CXOutsideTypes$type)
```
```{r}
CXoutsideBag <- neuronBag(CXOutsideNeurons,selfRef=TRUE,slctROI=outputRegions,verbose=TRUE,computeKnownRatio=TRUE)
CXOutsideBag <- cxRetyping(CXoutsideBag)
CXOutsideBagCompressed <- combineRois(CXOutsideBag,outputRegions,"Outside_regions")


## Re-filter on the "known weights". Filters out neurons that don't really innervate those regions
CXOutTable <- CXOutsideBagCompressed$outputs
CXOutTable <- filter(CXOutTable,knownTotalROIweight>20 & knownTotalPreWeight>20)

## Filter for inputs "proper": they're not receiving from CX neurons
CXInTable <- CXOutsideBagCompressed$inputs
CXInTable <- filter(CXInTable,knownTotalROIweight>20 & knownTotalPreWeight>20 & !(type.from %in% CXNeurons$type))

sort(unique(CXInTable$type.to))
unique(CXOutTable$type.from)


unidentifiedOutputs <- filter(CXOutsideBagCompressed$outputsTableRef,(type %in% CXOutTable$type.to) & !(type %in% CXNeurons$type))
knownInputs <- filter(CXOutsideBagCompressed$names,type %in% CXInTable$type.to)
reafferentPathways <- get_type2typePath(unidentifiedOutputs,knownInputs,ROI = list("Outside_regions"=outputRegions),n_steps = 1:2,stat = "knownOutputContribution")
## Of output neurons that are also inputs, how much do they contribute to the CX vs other neurons. 
CXInContrib <- filter(CXInTable,type.from %in% CXOutTable$type.to) %>% group_by(type.from) %>% summarize(CXContribIn = sum(knownOutputContribution)) %>% rename(type=type.from)

#CXOutTable <- mutate(CXOutTable,reafference1Index = CXInContrib$CXContribIn[match(type.to,CXInContrib$type)])
#CXOutTable$reafference1Index[is.na(CXOutTable$reafference1Index)] <- 0

CXContrib <- left_join(CXInContrib,CXOutContrib)
ggplot(CXOutTable,aes(x=reafference1Index,group=type.from)) + geom_histogram() + facet_wrap(type.from~.)
```



Get everything connecting to those in the output regions
```{r}
outputBag <- neuronBag(CXPotentialOutputNeurons,selfRef = TRUE,slctROI=outputRegions,verbose=TRUE,computeKnownRatio=TRUE,omitInputs = TRUE)
outputBag <- cxRetyping(outputBag)
## What is actually in there
outputRegionsStrict <- unique(outputBag$outputs$roi)
outputBagCompressed <- combineRois(outputBag,outputRegionsStrict,"Output_Regions")
outputTable <- outputBagCompressed$outputs %>% mutate(category="output")

outputTable$category[outputTable$databaseType.to %in% CXtypes$databaseType] <- "CX loop"
outputTable$category[outputTable$type.from ==  outputTable$type.to] <- "Self"
outputTable$category[startsWith(outputTable$type.to,"AOTU") | startsWith(outputTable$type.to,"TuBu")] <- "Efference"

outputTable <- outputTable %>% group_by(type.from) %>% mutate(pureFeedbacks = all(category != "output"))

CXOutputs <- filter(CXPotentialOutputs,type %in% filter(outputTable,pureFeedbacks==FALSE)$type.from)
CXOutputNeurons <- filter(CXPotentialOutputNeurons,type %in% filter(outputTable,pureFeedbacks==FALSE)$type.from)
```



### Cluster on the connectivity

```{r}
cxClOnOut <- connectivityCluster(outputsTable = CXOutTable,ROIs="Outside_regions",knownStats = TRUE,grouping="type")
cxClOnOut <- setClusters(cxClOnOut)
```

```{r}
outputTable <- cxClOnOut$outputsTable %>% mutate(type.fromF = factor(type.from,levels=cxClOnOut$hc$labels[cxClOnOut$hc$order]))
outputTable <- outputTable %>% group_by(type.from) %>% mutate(normOutputContrib = knownOutputContribution/sum(knownOutputContribution))

outputKind <- ggplot(outputTable,aes(x=type.fromF,y=normOutputContrib)) + geom_col(aes(fill=category)) + theme_paper(panel.spacing=unit(1, "lines")) + theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5)) + scale_fill_paletteer_d("ggthemes::Color_Blind",name="Partner type") +xlab("Central complex output type") + ylab("Fraction of significant output weights")
outputKind <- outputKind + facet_grid(.~supertype2.from,scales="free",space = "free")
outputKind
```
Per type categories:
```{r}
categorySwap <- function(cats){
   cats <- unique(cats)
   if ("CX loop" %in% cats){return("Feedback")}
   if (length(cats)==1){return(cats)}
}

outputTable <- outputTable %>% group_by(type.to) %>%
   mutate(type_category=categorySwap(category))   
```

Most targets are receiving from a single cluster. 
```{r}
outputTablePerCluster <- outputTable %>% group_by(cluster.from,type.to,category) %>% summarize(clusterContrib=sum(knownWeightRelative)) %>% ungroup()

outputTableClusterInfluences <- outputTablePerCluster %>% group_by(type.to,category) %>% summarize(mainContrib=cluster.from[which.max(clusterContrib)],mainContribFraction=clusterContrib[which.max(clusterContrib)]/sum(clusterContrib))

outputSparsenessPlot <- ggplot(outputTableClusterInfluences,aes(x=mainContribFraction)) + geom_histogram() + facet_wrap(category ~.) + theme_paper()
outputSparsenessPlot
```
We can assign the targets to their main input cluster (column `clusterEq.to`), and give cluster names based on the input innervation (columns `clusterName.from` and `clusterNameEq.to`)
```{r}
outputTable <- mutate(outputTable,clusterEq.to=outputTableClusterInfluences$mainContrib[match(type.to,outputTableClusterInfluences$type.to)]) 

outputTable <- outputTable %>% group_by(cluster.from) %>% mutate(clusterName.from=paste(unique(type.from),collapse="/"))
outputTable <- outputTable %>% mutate(clusterNameEq.to=outputTable$clusterName.from[match(clusterEq.to,outputTable$cluster.from)])
```


Plot the clustering results
```{r}
outClusterPlot <- plotClusters(cxClOnOut,colorAxis = T,theme = theme_paper_map(),h=0.8)
outClusterPlot
```


And the connection tables sorted by category:
```{r}
outputConnectivity <- plotConnectivity(filter(outputTable,type_category=="output"),xaxis="outputs",theme=theme_paper(panel.background=element_rect(fill="gray95")),orderIn=cxClOnOut,connectionMeasure ="knownWeightRelative",facetInputs = "cluster.from",facetOutputs = "clusterEq.to") #+ scale_x_discrete(labels=NULL)
loopConnectivity <- plotConnectivity(filter(outputTable,category=="CX loop" | category=="self" | category=="Efference"),xaxis="outputs",theme=theme_paper(panel.background=element_rect(fill="gray95")),orderIn=cxClOnOut,connectionMeasure = "knownWeightRelative",facetInputs = "cluster.from",facetOutputs = "clusterEq.to")

outputConnectivity
loopConnectivity
```


```{r}
save_plot("~/loopConnectivity.svg",loopConnectivity,ncol=1.5,nrow=1.5)
save_plot("~/outputConnectivity.svg",outputConnectivity,ncol=1.5,nrow=1.5)
save_plot("~/outputKind.svg",outputKind,ncol=1.5,nrow=1)
```


## Plotting output synapses of CX "output" neurons
First augment the references with the "cluster" information
```{r}
CXTargets <- outputBagCompressed$outputsTableRef %>% filter(type %in% outputBagCompressed$outputs$type.to) %>%
   mutate(type_category=outputTable$type_category[match(type,outputTable$type.to)])   

CXOutputNeurons <- mutate(CXOutputNeurons,cluster=outputTable$cluster.from[match(type,outputTable$type.from)],
                                          clusterName=outputTable$clusterName.from[match(type,outputTable$type.from)])
CXTargets <- mutate(CXTargets,cluster=outputTable$clusterEq.to[match(type,outputTable$type.to)],
                              clusterName=outputTable$clusterNameEq.to[match(type,outputTable$type.to)])
```

Then make tables of synapses
```{r,warning=FALSE}
CXOutSyn <- collectSynapses(CXOutputNeurons,outputRegionsStrict,polarity="post")

targetOutputSyn <- collectSynapses(filter(CXTargets,type_category=="output"),outputRegions,polarity="post")

targetFeedback <- collectSynapses(filter(CXTargets,type_category=="Feedback"),"CX",polarity="post")
```


```{r}
rPal <- roisPalette()
CXCol <- rPal["CX"]
typesPal <- supertype2Palette()
EBMesh <- neuprint_ROI_mesh("EB")
FBMesh <- neuprint_ROI_mesh("FB")
PBMesh <- neuprint_ROI_mesh("PB")
NOMesh <- neuprint_ROI_mesh("NO")
LALRMesh <- neuprint_ROI_mesh("LAL(-GA)(R)")
CREMesh <- neuprint_ROI_mesh("CRE(R)")
SMPMesh <- neuprint_ROI_mesh("SMP(R)")
SPSMesh <- neuprint_ROI_mesh("SPS(R)")
SIPMesh <- neuprint_ROI_mesh("SIP(R)")
SLPMesh <- neuprint_ROI_mesh("SLP(R)")
GARMesh <- neuprint_ROI_mesh("GA(R)")
WEDMesh <- neuprint_ROI_mesh("WED(R)")
IPSMesh <- neuprint_ROI_mesh("IPS(R)")
GNGMesh <- neuprint_ROI_mesh("GNG")
GORMesh <- neuprint_ROI_mesh("GOR(R)")
IBMesh <- neuprint_ROI_mesh("IB")
ICLMesh <- neuprint_ROI_mesh("ICL(R)")
```

```{r}
nopen3d()
par3d(windowRect = c(30, 30, 1530, 1530))
plot3d(EBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE)
plot3d(FBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(PBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(NOMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(LALRMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(GARMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(CREMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SMPMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(WEDMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SLPMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SIPMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SPSMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
par3d(scale=c(1,1,1))
for (cl in unique(CXOutSyn$cluster)){
   plot3d(filter(CXOutSyn,cluster==cl)[,c("x","y","z")],col=paletteer::paletteer_d("Polychrome::palette36")[cl+2],add=T)
}
nview3d("ventral")
rgl.snapshot(paste0(outputsFolder,"frontAllOuts.png"))
nview3d("right",extramat=rotationMatrix(-pi/2, 1, 0, 0))
rgl.snapshot(paste0(outputsFolder,"sideAllOuts.png"))
```
```{r}
nopen3d()
par3d(windowRect = c(30, 30, 1530, 1530))
plot3d(EBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE)
plot3d(FBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(PBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(NOMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(LALRMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(GARMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(CREMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SMPMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(WEDMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SLPMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SIPMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(SPSMesh,color="white",alpha=0.2,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
par3d(scale=c(1,1,1))
for (cl in unique(CXTargets$cluster)){
   plot3d(filter(targetOutputSyn,cluster==cl)[,c("x","y","z")],col=paletteer::paletteer_d("Polychrome::palette36")[cl+2],add=T)
}
nview3d("ventral")
rgl.snapshot(paste0(outputsFolder,"frontAllOutputTargets.png"))
nview3d("right",extramat=rotationMatrix(-pi/2, 1, 0, 0))
rgl.snapshot(paste0(outputsFolder,"sideAllOutputTargets.png"))
```

```{r}
allOutViews <- ggdraw(xlim = c(0,2)) + draw_image(paste0(outputsFolder,"frontAllOuts.png"),scale=1.6,clip="on") + draw_image(paste0(outputsFolder,"sideAllOuts.png"),scale=1.6,hjust=-0.9,clip="on") + theme_paper_map()
allOutViews
```

```{r}
nopen3d()
par3d(windowRect = c(30, 30, 1530, 1530))
plot3d(EBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE)
plot3d(FBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(PBMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
plot3d(NOMesh,color=CXCol,alpha=0.1,xlab="",ylab="",zlab="",box=FALSE,axes=FALSE,add = T)
par3d(scale=c(1,1,1))
for (cl in unique(CXTargets$cluster)){
   plot3d(filter(targetFeedback,cluster==cl)[,c("x","y","z")],col=paletteer::paletteer_d("Polychrome::palette36")[cl+2],add=T)
}
nview3d("ventral")
rgl.snapshot(paste0(outputsFolder,"frontAllFeedbackTargets.png"))
nview3d("right",extramat=rotationMatrix(-pi/2, 1, 0, 0))
rgl.snapshot(paste0(outputsFolder,"sideAllFeedbackTargets.png"))
```

Summaries of those different types/clusters
```{r}
## Create a summary restricted to the output regions
CXOutputSummary <- filter(getRoiInfo(CXOutputNeurons$bodyid),roi %in% outputRegionsStrict & !is.na(downstream)) 
CXOutputSummary <- left_join(CXOutputSummary,select(CXOutputNeurons,bodyid,type,databaseType,supertype1,supertype2,supertype3),by="bodyid")
## 
CXOutputSummary <- mutate(CXOutputSummary,
                          cl=outSynClCut[type],
                          clName=clNames[cl]) %>%
   group_by(bodyid,type,cl,clName,databaseType,supertype1,supertype2,supertype3) %>% summarize(downstreamOutputRegion=sum(downstream)) %>% group_by(type) %>% mutate(n_type=n()) %>% ungroup()

CXOutputSummary <- mutate(CXOutputSummary,
                          typeF=factor(CXOutputSummary$type,levels=colnames(overlapMat)[outSynClusters$order])) %>% 
   arrange(typeF) %>% 
   mutate(typeFN=paste0(typeF," (n=",n_type,")"),
          typeFN=factor(typeFN,levels=unique(typeFN)))

```

```{r}
moduleSummaryPlot <- ggplot(CXOutputSummary,aes(x=typeFN,y=downstreamOutputRegion,col=clName)) + geom_point(size=3) + theme_paper_grid() +scale_color_manual(name="Module",breaks=names(overlapCols),values=overlapCols) + 
   theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5,colour = overlapCols)) + xlab("") + ylab("Number of downstream synapses")
moduleSummaryPlot
```




## What do their respective innervation patterns look like ?
```{r}
roisOut <- selectRoiSet(roiH,exceptions=list("LAL(R)"=4,"CRE(R)"=4))
roisOut <- roisOut %>% filter(!(level2 %in% c("ATL(L)","ICL(L)")))
roiOutLabels <- selectRoiSet(roiH,default_level = 0)
```
```{r}
CXOutputSummary <- getROISummary(CXOutputNeurons,threshold=20)
```


```{r}
outputsInnervation_L <- haneschPlot(CXOutputSummary,roiSelect = roisOut,grouping = "supertype2",roiLabel = roiOutLabels,flip=TRUE,interactive=TRUE,theme = theme_paper_grid(),showCount = T)
outputsInnervation_L
```

```{r}
save_plot("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/CXoutputsHaneschL.svg",outputsInnervation_L,ncol=2,nrow=1.2,base_width = 8.5/2)
```

## Who are those neurons they talk to?
Classify them in broad categories, add the cluster information


```{r}
ddConn <- as.dendrogram(connCl)
ddConnData <- dendro_data(ddConn, type = "rectangle")
clustConn <- ggplot(segment(ddConnData)) + geom_segment(aes(x=x, y=y, xend=xend, yend=yend))  + theme_paper_map()+theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust = 0.5)) + xlab("")+ scale_y_reverse()+coord_fixed(ratio=5) + scale_x_discrete(breaks=1:nrow(N1Mat),labels=rownames(N1Mat)[connCl$order])
#clustTypes2 <- ggplot(segment(ddTypesData)) + geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) + scale_x_continuous(breaks=1:nrow(overlapMat),labels=colnames(overlapMat)[outSynClusters$order])+ theme_paper_map() + theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust = 0.5))
#clustConn / clustTypes2
clustConn
```

```{r}
ddConnOut <- as.dendrogram(connClOut)
ddConnDataOut <- dendro_data(ddConnOut, type = "rectangle")
clustConnOut <- ggplot(segment(ddConnDataOut)) + geom_segment(aes(x=x, y=y, xend=xend, yend=yend))  + theme_paper_map()+theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust = 0.5)) + xlab("")+ scale_y_reverse()+coord_fixed(ratio=40) + scale_x_continuous(breaks=1:nrow(N1MatOut),labels=rownames(N1MatOut)[connClOut$order])
#clustTypes2 <- ggplot(segment(ddTypesData)) + geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) + scale_x_continuous(breaks=1:nrow(overlapMat),labels=colnames(overlapMat)[outSynClusters$order])+ theme_paper_map() + theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust = 0.5))
#clustConn / clustTypes2
clustConnOut
```




```{r}
targetCounts <- group_by(outputsN1Table,type.to,category) %>% summarize(nCl=length(unique(cl)),nT=n(),CXInfluence=sum(knownWeightRelative),CXMain=max(knownWeightRelative)/sum(knownWeightRelative))
ggplot(filter(targetCounts,category!="Self" & nCl>1),aes(x=CXMain)) + geom_histogram() + facet_grid(nT~category) + theme_paper_hgrid()
filter(targetCounts,nCl>1 & category=="output")
```


```{r}
outputSynapsesOverview <- (allOutViews + 
   ((connClPlot + theme(plot.margin = margin(b=0))) / (clustConn + theme(plot.margin = margin(t=0)))) + 
   plot_layout(widths=c(3.5,1))) /
   (moduleSummaryPlot + outputKind) + plot_layout(guides="keep",heights=c(3,1)) + plot_annotation(tag_levels="A")
outputSynapsesOverview
save_plot(paste0(outputsFolder,"OutputsPanel1.pdf"),outputSynapsesOverview,nrow=4,ncol=4,device=cairo_pdf)
```


We'll select all their partners in "output" regions
```{r}
allOuts <- outputBagCompressed$outputsTableRef %>% filter(type %in% outputsN1Table$type.to)

## Proper "outputs" are not other CX neurons
realOuts <- filter(allOuts,!(databaseType %in% CXtypes$databaseType))
cxOutLoops <- filter(allOuts,(databaseType %in% CXtypes$databaseType))
```

Augment the output list with the mirror symetric for all the neurons that cross?
```{r}
outsRoiInfo <- getROISummary(realOuts,threshold=10)
bilat <- group_by(outsRoiInfo,type,databaseType) %>% summarise(bilateral = any(grepl("(R)",roi,fixed=T)) & any(grepl("(L)",roi,fixed=T)))
bilatTable <- getTypesTable(filter(bilat,bilateral==TRUE & !is.na(databaseType))$databaseType)
bilatTable <- lateralize_types(bilatTable,postfix="raw")
othersTable <- filter(realOuts,!(databaseType %in% bilatTable$databaseType))
realOutsAugmented <- rbind(othersTable,bilatTable)
```


Get all the connections for those output neurons (not in the CX as they're not going there) in broad regions
```{r}
realN1Bag <- create_neuronBag(realOutsAugmented,selfRef = TRUE,verbose=TRUE,computeKnownRatio=TRUE,chunk_meta=1000,slctROI=outputRegions)
feedbackBag <- create_neuronBag(cxOutLoops,selfRef = TRUE,verbose=TRUE,computeKnownRatio=TRUE,chunk_meta=1000)
```

```{r}
realN1Bag <- cxRetyping(realN1Bag)
feedbackBag <- cxRetyping(feedbackBag)
```

Look at the weight of those targets at a "global" output region level. Removing any single neuron getting less than 0.1% of inputs in those regions.
```{r}
N1Overview <- combineRois(realN1Bag,outputRegions,"Output regions",singleNeuronThreshold=0.001)
## One cleans up anything not getting input from our selection of CX neurons in the combined output regions
#signifOutputs <- unique(filter(outputsOverview$inputs,type.from %in% outputBag$names$type)$type.to)
#outputsOverview <- filter(outputsOverview,filterPartner=FALSE,type %in% signifOutputs)
```

```{r}
inputsN1Table <- N1Overview$inputs %>% mutate(category="extra")
inputsN1Table$category[inputsN1Table$databaseType.from %in% CXtypes$databaseType] <- "CX"
inputsN1Table$category[inputsN1Table$type.from ==  inputsN1Table$type.to] <- "Self"

outputsN1Table <- N1Overview$outputs %>% mutate(category="outputs")
outputsN1Table$category[outputsN1Table$databaseType.to %in% CXtypes$databaseType] <- "CX"
outputsN1Table$category[outputsN1Table$type.to %in% outputsN1Table$type.from] <- "Feedback"
outputsN1Table$category[outputsN1Table$type.to == outputsN1Table$type.from] <- "Self"

```

```{r}
N1MatFull <- connectivityMatrix(filter(inputsN1Table,type.to %in% realOuts$type),slctROIs = "Output regions",allToAll = FALSE,from = "type.from",to="type.to",value = "knownWeightRelative",ref="outputs")
N1MatNoCX <- connectivityMatrix(filter(inputsN1Table,category!="CX" & (type.to %in% realOuts$type)),slctROIs = "Output regions",allToAll = FALSE,from = "type.from",to="type.to",value = "knownWeightRelative",ref="outputs")
N1MatFromOutputs <- connectivityMatrix(filter(outputsN1Table,category!="CX" & (type.from %in% realOuts$type)),slctROIs = "Output regions",allToAll = FALSE,from = "type.from",to="type.to",value = "knownOutputContribution")

N1DistFull <- cos_dist(N1MatFull)
N1DistNoCX <- cos_dist(N1MatNoCX)
N1DistFromOutputs <- cos_dist(N1MatFromOutputs)

connClFull <- hclust(N1DistFull)
connClFullCut <- cutree(connClFull,h=0.8)

connClNoCX <- hclust(N1DistNoCX)
connClNoCXCut <- cutree(connClNoCX,h=0.8)
```

```{r}
plot_dist(N1DistNoCX)+
   theme_paper_map() + scale_fill_distiller(palette = "Greys",name = "Cosine distance") +xlab("")+ylab("") +
   theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5))

plot_dist(N1DistFromOutputs)+
   theme_paper_map() + scale_fill_distiller(palette = "Greys",name = "Cosine distance") +xlab("")+ylab("") +
   theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5))
```


```{r}
clComp <- data.frame(type=names(connClFullCut)) %>% mutate(CXCl = connClOutCut[type], fullCl = connClFullCut[type], outCl = connClNoCXCut[type])
clCompSum <- group_by(clComp,outCl) %>% summarize(nFrom = length(unique(CXCl)),nNeuron=n()) %>% group_by(nNeuron,nFrom) %>% mutate(ct=n()) %>% ungroup()
ggplot(clCompSum) + geom_point(aes(x=nNeuron,y=nFrom,size=ct)) + geom_abline()
```
```{r}
inputsN1Melted <- df_conn_mat(N1MatFromOutputs,rank(connClOut$order[connClOut$order[connClOut$labels %in% filter(outputsN1Table,category!="CX"  & type.from %in% realOuts$type)$type.from]]),
                              1:ncol(N1MatFromOutputs))
inputsN1Melted <- mutate(inputsN1Melted,
                       clIn=connClOutCut[as.character(Inputs)],
                       category=outputsN1Table$category[match(Inputs,outputsN1Table$type.from)])

ggplot(filter(inputsN1Melted,category=="outputs")) + geom_tile(aes(x=Inputs,y=Outputs,fill=value)) + theme_paper_map() + theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5),axis.text.y=element_text()) + xlab("") + ylab("") + facet_grid(. ~ clIn,scales="free",space="free") + scale_fill_gradient2(low="#F7F2F7", mid="blueviolet", high="black", 
                         midpoint =0.5, limits=c(0,1)) 
```



## Find feedback pathways in there.
```{r}
CXRois <- unique(unlist(roiH %>% filter(level1=="CX")))
```
```{r}
feedbackNeurons <- unique((outputsInOutBag$outputs %>% filter((databaseType.to %in% CXtypes$databaseType) & (roi %in% CXRois)))$type.from)
feedbackBag <- filter(outputsInOutBag,filterPartners=FALSE,type %in% feedbackNeurons)
```

```{r}
roisFeedback <- selectRoiSet(roiH,exceptions=list("LAL(R)"=4,"CRE(R)"=4,"EB"=4,"FB"=4))
```


```{r}
feedbackRoiSummary <- getROISummary(feedbackBag,threshold = 20)
```

```{r}
feedbackHanesch <- haneschPlot(feedbackRoiSummary,grouping="supertype2",flip=TRUE,roiSelect=roisOut,roiLabel=roiOutLabels)
feedbackHanesch
```

```{r}
feedbackHaneschUnpacked <- haneschPlot(feedbackRoiSummary,grouping="supertype2",flip=TRUE,roiSelect=roisFeedback,roiLabel=roiOutLabels)
feedbackHaneschUnpacked
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/feedbacksHanesch.svg",feedbackHanesch,width=12,height=7)
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/feedbacksHaneschLayers.svg",feedbackHaneschUnpacked,width=14,height=7)
```

```{r}
feedbackPathwaysG <- makeGraph(feedbackBag$inputs %>% filter(type.from %in% outputBag$names$type),roiSelect = (roisOut %>% filter(level1 != "CX")),roiLabel = roiOutLabels)
```

```{r}
feedbackGraphPlot <- ggraph(feedbackPathwaysG$graph,layout="stress") + 
      geom_edge_fan(aes(width=weightRelative,color=roi),alpha=0.5,color="grey") + 
      geom_edge_loop(aes(direction=10,span=10,width=weightRelative),alpha=0.5) +
      geom_node_point(aes(color=supertype2,shape=as.factor(layers)),size=8,alpha=0.5) +
      scale_color_paletteer_d("Polychrome::palette36") +
      geom_node_text(aes(label=name),size=4) +
      scale_edge_width(name="Relative weight") +
      scale_edge_color_discrete() + theme_void()
feedbackGraphPlot + facet_edges(region~.)
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/feedbacksGraph.svg",feedbackGraphPlot,width=12)
```




```{r}
PFL1Summary <- outputsOutputPlotSummary(outputBag,outputsSuperSummary,inputType="PFL1_L*")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/PFL1Summary.svg",PFL1Summary)
PFL1Summary
```


```{r}
PFL1Outputs <- outputsOutputPlot(outputBag,outputsOutputsByRoi,inputType = "PFL1_L*")
```

```{r}
PFL1Outputs
```


```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/PFL1Outs.svg",PFL1Outputs)
```

```{r}
PFL2Outputs <- outputsOutputPlot(outputBag,outputsOutputsByRoi,"PFL2_L")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/PFL2Outs.svg",PFL2Outputs,height=12)
PFL2Outputs
```
```{r}
PFL2Summary <- outputsOutputPlotSummary(outputBag,outputsSuperSummary,inputType="PFL2_L")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/PFL2Summary.svg",PFL2Summary,height=9)
PFL2Summary
```

```{r}
PFL3Outputs <- outputsOutputPlot(outputBag,outputsOutputsByRoi,"PFL3_L*")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/PFL3Outs.svg",PFL3Outputs,height=15)
PFL3Outputs
```
```{r}
PFL3Summary <- outputsOutputPlotSummary(outputBag,outputsSuperSummary,inputType="PFL3_L*")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/PFL3Summary.svg",PFL3Summary,height=10)
PFL3Summary
```

```{r}
ExR7Outputs <- outputsOutputPlot(outputBag,outputsOutputsByRoi,"ExR7_L")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/ExR7Outs.svg",ExR7Outputs,height=12)
ExR7Outputs
```

```{r}
ExR7Summary <- outputsOutputPlotSummary(outputBag,outputsSuperSummary,inputType="ExR7_L")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/ExR7Summary.svg",ExR7Summary,height=9)
ExR7Summary
```


```{r}
ExR8Outputs <- outputsOutputPlot(outputBag,outputsOutputsByRoi,"ExR8_R")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/ExR8Outs.svg",ExR8Outputs,height=12)
ExR8Outputs
```
```{r}
ExR8Summary <- outputsOutputPlotSummary(outputBag,outputsSuperSummary,inputType="ExR8_R")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/ExR8Summary.svg",ExR8Summary,height=9)
ExR8Summary
```


```{r}
FC1Summary <- outputsOutputPlotSummary(outputBag,outputsSuperSummary,"FC1",inputCol = "supertypeFrom1")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/FC1Summary.svg",FC1Summary,height=10)
FC1Summary
```
```{r}
FC2Summary <- outputsOutputPlotSummary(outputBag,outputsSuperSummary,"FC2",inputCol = "supertypeFrom1")
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/FC2Summary.svg",FC2Summary,height=10)
FC2Summary
```

```{r}
DNOutOut <- outputsInOutBag$outputs %>% filter(startsWith(databaseTypeTo,"DN"))
```

```{r}
unique(DNOutOut$type.to)
```

```{r}

```

### In the LAL
```{r}
LALOutPyramid <- makePyramidGraph(outputBag,ROIs = "LAL(-GA)(R)",polarity = "outputs",plot = TRUE)
LALOutPyramid
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/LALOutPyramid.svg",LALOutPyramid,width=49,height=10)
```

```{r}
CREOutPyramid <- makePyramidGraph(outputBag,ROIs = "CRE(-ROB,-RUB)(R)",polarity = "outputs",plot = TRUE)
CREOutPyramid
```
```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/CREOutPyramid.svg",CREOutPyramid,width=49,height=10)
```

```{r}
ROBOutPyramid <- makePyramidGraph(outputBag,ROIs = "ROB(R)",polarity = "outputs",plot = TRUE)
ROBOutPyramid
```
```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/ROBOutPyramid.svg",ROBOutPyramid,width=18,height=10)
```

```{r}
RUBOutPyramid <- makePyramidGraph(outputBag,ROIs = "RUB(R)",polarity = "outputs",plot = TRUE)
RUBOutPyramid
```
```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/RUBOutPyramid.svg",RUBOutPyramid,width=18,height=10)
```

```{r}
SMPOutPyramid <- makePyramidGraph(outputBag,ROIs = "SMP(R)",polarity = "outputs",plot = TRUE)
SMPOutPyramid
```

```{r}
ggsave("~/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NewOutputs/SMPOutPyramid.svg",SMPOutPyramid,width=30,height=10)
```


## "Homogeneity" plots
```{r}
lalOutputsF <- PFLInOut$outputs_raw %>% filter(paste0(type.from,type.to) %in% paste0(PFLInOut$outputs$type.from,PFLInOut$outputs$type.to) & roi == "LAL(-GA)(R)" & !(grepl("PFL1|PFL2|PFL3",type.to)))
```


```{r}
PFL_breakdown <- ggplot(lalOutputsF,aes(x=name.from,y=weightRelative,group=to,color=as.factor(to))) + geom_point() + geom_line() + facet_wrap(~databaseTypeFrom+type.to ,drop=TRUE,scales = "free_x") + theme_paper() + theme(axis.text.x = element_text(angle = 90))+  guides(color="none")+ labs(y="Relative weight in the LAL",x="Input Neuron")
PFL_breakdown
```


## Clustering  based on synapse overlap
How much do synapses from different types overlap with each other?

```{r}
## Compute the nearest neighbor in another synapse set for all synapses
OutputSynNNDists <- nncrossCross(CXOutSyn,by="type")

## Summarise as the proportion of synapses from the other type closer than 1um
CXOutOverlap <- group_by(OutputSynNNDists,type,to) %>% summarize(overlap=mean(distance<1000/8)) %>% ungroup()

## Put the average of type1 to type2 and type2 to type1 in a matrix for clustering purposes (really for ordering)
overlapMat <- matrix(nrow=length(unique(CXOutOverlap$type)),ncol=length(unique(CXOutOverlap$type)))
rownames(overlapMat) <- CXOutputs$type
colnames(overlapMat) <- CXOutputs$type
for (t in CXOutputs$type){
   for (t2 in CXOutputs$type){
      overlapMat[t,t2] <- mean(filter(CXOutOverlap,(type==t & to==t2) | (type==t2 & to==t))$overlap)
   }
}

## Cluster
outSynClusters <- hclust(as.dist(1-overlapMat))
outSynClCut <- cutree(outSynClusters,h=0.99)

## Reorder the table with factors
CXOutOverlap$typeF <- factor(CXOutOverlap$type,levels=colnames(overlapMat)[outSynClusters$order])
CXOutOverlap$toF <- factor(CXOutOverlap$to,levels=colnames(overlapMat)[outSynClusters$order])
```

```{r}
ddTypes <- as.dendrogram(outSynClusters)
ddTypesData <- dendro_data(ddTypes, type = "rectangle")
clustTypes <- ggplot(segment(ddTypesData)) + geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) + scale_x_discrete(breaks=1:nrow(overlapMat),labels=colnames(overlapMat)[outSynClusters$order]) + scale_y_reverse()+ theme_paper_map() +coord_fixed(ratio=5)
clustTypes
```


```{r}
CXOutOverlap <- mutate(CXOutOverlap,cl=outSynClCut[type])
CXOutSyn <- mutate(CXOutSyn,cl=outSynClCut[type])
```

Name the "modules"
```{r}
clNames <- sapply(1:max(outSynClCut),function(i) paste(names(outSynClCut[outSynClCut==i]),collapse ="/"))
CXOutOverlap <- mutate(CXOutOverlap,clName=clNames[cl])
CXOutSyn <- mutate(CXOutSyn,clName=clNames[cl])

## Also create a palette for it
overlapCols <- paletteer::paletteer_d("Polychrome::dark")[outSynClCut[colnames(overlapMat)[outSynClusters$order]]]
names(overlapCols) <- clNames[outSynClCut[colnames(overlapMat)[outSynClusters$order]]]
```

```{r}
overlapPlot <- ggplot(CXOutOverlap,aes(x=typeF,y=toF)) + geom_tile(aes(fill=overlap)) + 
   theme_paper_map() + 
   theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5,colour = overlapCols),axis.text.y = element_text(colour = overlapCols)) + 
   scale_fill_distiller(palette = "Greys",trans="reverse") +xlab("")+ylab("")+coord_fixed()
overlapPlot
```
