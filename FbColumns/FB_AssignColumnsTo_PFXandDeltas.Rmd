---
title: "Notebook assigning columns to PB-FB-XX (ie PFX) and Delta0/6 neurons"
output:
  html_document:
    df_print: paged
---

### Command to clear environment is: rm(list = ls(all.names = TRUE))
### Command to update is remotes::update_packages('neuprintr')
### Load libraries
```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(dplyr)
library(matlib)
library(RColorBrewer)
library(ggraph)
library(robustbase)
require(alphahull)
library(zoo)
library(ggpubr)
options(nat.plotengine = 'rgl')
```

### Configurable inputs: choose ROI and save/plot directories
```{r}

# The region of interest.
ROI="FB"  

# Directory to save data to.
SaveDir="C:/Users/labadmin/Documents/Cx_EM_Analysis/BradData/FB_Analysis/"

# Directory to save plots to.
PlotDir="C:/Users/labadmin/Documents/Cx_EM_Analysis/BradData/FB_Analysis/ColumnarSynapseLocs/"


```


### Connect to neuprint server.
```{r}
neuprint_login()
```

### Get general functions
```{r}

source("FB_SynapseDistribution_Utils.r")
source("FB_LayerOutline_Utils.r")

```


# Load pre-processed data and remove variables that won't be used
```{r}

load(paste(SaveDir,"FBColumnarSynapses_PostPCA.RData",sep=""))
rm(list=c("roiEigen","Mesh_FB_Points","Mesh_FB_L1_Points", "Mesh_FB_L2_Points","Mesh_FB_L3_Points", "Mesh_FB_L4_Points",
          "Mesh_FB_L5_Points", "Mesh_FB_L6_Points","Mesh_FB_L7_Points", "Mesh_FB_L8_Points", "Mesh_FB_L9_Points"))

```


# Get PB glomeruli or columns (Some columns are mixed and are named _L1/2 for example)
```{r}


# Assign side (pb or fb column half)
FBC_SynsAll$Side=NA
FBC_SynsAll$Side[grepl("_R",FBC_SynsAll$bodyname)]<-"R"
FBC_SynsAll$Side[grepl("_L",FBC_SynsAll$bodyname)]<-"L"

# Assign PB glom
FBC_SynsAll$PBglom=NA
RightColumns=str_extract(FBC_SynsAll$bodyname, "_R(\\d+)")
LeftColumns=str_extract(FBC_SynsAll$bodyname, "_L(\\d+)")
FBC_SynsAll$PBglom[which(!is.na(RightColumns))]=RightColumns[which(!is.na(RightColumns))]
FBC_SynsAll$PBglom[which(!is.na(LeftColumns))]=LeftColumns[which(!is.na(LeftColumns))]
FBC_SynsAll$PBglom=sapply(FBC_SynsAll$PBglom, substring, 2, 3)

# Assign FB glom
FBC_SynsAll$FBcol=NA
FBC_SynsAll$FBcol=str_extract(FBC_SynsAll$bodyname, "_C(\\d+)")
FBC_SynsAll$FBcol=sapply(FBC_SynsAll$FBcol, substring, 2, 3)


# Manually change PB glom of one neuron (PFNp_a)
FBC_SynsAll$PBglom[FBC_SynsAll$bodyid == 5813128416] = NA # development error. 


```


# Get the line that bisects each FB layer in the XZ (horizontal) plane
```{r}

Mid_L1=Get_Mid(Outline_L1_XZ)
Mid_L2=Get_Mid(Outline_L2_XZ)
Mid_L3=Get_Mid(Outline_L3_XZ)
Mid_L4=Get_Mid(Outline_L4_XZ)
Mid_L5=Get_Mid(Outline_L5_XZ)
Mid_L6=Get_Mid(Outline_L6_XZ)
Mid_L7=Get_Mid(Outline_L7_XZ)
Mid_L8=Get_Mid(Outline_L8_XZ)


```



# Get synapse distribution information from FX neurons and plot the data for review
```{r}


# Make plotting directories
Fx_Dir=paste(PlotDir,"FX_Plots_All","/",sep="")
Fx_Dir_Dist=paste(Fx_Dir,"FX_MeasureWidth","/",sep="")
Fx_Dir_SynScatter=paste(Fx_Dir,"FX_SynScatter","/",sep="")
Fx_Dir_Crosses=paste(Fx_Dir,"FX_Crosses","/",sep="")
if (!dir.exists(Fx_Dir)){dir.create(Fx_Dir)}
if (!dir.exists(Fx_Dir_Dist)){dir.create(Fx_Dir_Dist)}
if (!dir.exists(Fx_Dir_SynScatter)){dir.create(Fx_Dir_SynScatter)}
if (!dir.exists(Fx_Dir_Crosses)){dir.create(Fx_Dir_Crosses)}

# Get all FX neurons (FC, FS, FR)
FX_SynsAll=subset(FBC_SynsAll, !(is.na(FBcol)) & startsWith(type,"F"))
FX_SynsAll$FBcol=factor(FX_SynsAll$FBcol, levels=sort(unique(FX_SynsAll$FBcol)) )


# Get synapse distributions per layer
FX_Distribution=Get_SynLayerDistribution(FX_SynsAll, 25, Fx_Dir_Dist) # 25 is good here, needs to match PFX/Delta0 threshold below.


# Plot distribution of all synapses in entire FB and by layer
PlotSyns_byColumn(FX_SynsAll, "FX All", "FX_All", Fx_Dir, TRUE, TRUE)
PlotSyns_byLayer(FX_SynsAll, "FX All", "FX_All_Layers", "FBcol", Fx_Dir_SynScatter, TRUE, TRUE)


# Make the same plots but per neuron type 
FX_Types=unique(FX_SynsAll$type)
for (ttt in 1:length(FX_Types)){
  SubData=subset(FX_SynsAll, type == FX_Types[ttt])
  PlotSyns_byColumn(SubData, FX_Types[ttt], paste("FX_",FX_Types[ttt],sep=""), Fx_Dir_SynScatter, TRUE, FALSE)
}
for (ttt in 1:length(FX_Types)){
  SubData=subset(FX_SynsAll, type == FX_Types[ttt])
  PlotSyns_byLayer(SubData, FX_Types[ttt], paste("FX_",FX_Types[ttt],"_Layers",sep=""), "FBcol", Fx_Dir_SynScatter, FALSE, FALSE)
}
remove(SubData)


```



# For each layer, define mean column position based on FX data and plot for review.
# Here, FB column positions are defined for each layer using the FX neurons that innervate
# every column of that layer. This criteria cleans up the column positions by excluding neuron
# types that happen to have a few neurons with synapses in a layer but don't innervate all columns.
```{r}


# Get average X/Z position of each column in each layer
FX_Column_Positions = as.data.frame(FX_Distribution %>% group_by(FBcol, Layer, type) %>% 
                                      summarise(X_Mean = mean(X_Mean), Y_Mean=mean(Y_Mean), Z_Mean = mean(Z_Mean),
                                                Cross_XL_X = mean(Cross_XL_X), Cross_XL_Z = mean(Cross_XL_Z),
                                                Cross_XR_X = mean(Cross_XR_X), Cross_XR_Z = mean(Cross_XR_Z),
                                                Cross_YU_X = mean(Cross_YU_X), Cross_YU_Z = mean(Cross_YU_Z),
                                                Cross_YD_X = mean(Cross_YD_X), Cross_YD_Z = mean(Cross_YD_Z)))
 
                          
# Plot the distribution of FX column positions for all FX neuron types and each FX type individually 
PlotColumn_Aves(FX_Column_Positions, "FX_Columns_All", Fx_Dir_Crosses, FALSE)
PlotColumn_Types(FX_Column_Positions, "FX_Columns", Fx_Dir_Crosses, FALSE) 


# Subset FX column positions to include only those neurons that innervate all columns in a layer
FX_ColumnsInnervatedPerLayer= FX_Column_Positions %>% group_by(type, Layer) %>% summarise(n=n())
FX_ColumnsInnervatedPerLayer= subset(FX_ColumnsInnervatedPerLayer, n==9) 


# Get just those layers where the FX neuron types innervates all columns
FX_Column_Positions= inner_join(FX_Column_Positions, FX_ColumnsInnervatedPerLayer, by = c("type","Layer"))


# Replot data
PlotColumn_Aves(FX_Column_Positions, "FX_Columns_All_Clean", Fx_Dir_Crosses, FALSE)
PlotColumn_Types(FX_Column_Positions, "FX_Columns_Clean", Fx_Dir_Crosses, FALSE) 


# Subset FX_Distribution based on neurons that innervate all columns of a layer
FX_Distribution_Filt= inner_join(FX_Distribution, FX_ColumnsInnervatedPerLayer, by = c("type","Layer"))



```



# Get PB-FB-XX (ie PFX) and Delta0 synapse distribution data
```{r}

# Make PB-FB-X  plotting directory
PFX_Dir=paste(PlotDir,"PFX_Plots_All","/",sep="")
PFX_Dir_Dist=paste(PFX_Dir,"PFX_MeasureWidth","/",sep="")
PFX_Dir_Mapping=paste(PFX_Dir,"PFX_Mapping","/",sep="")
PFX_Dir_MapGraph=paste(PFX_Dir,"PFX_MapGraph","/",sep="")
PFX_Dir_Crosses=paste(PFX_Dir,"PFX_Crosses","/",sep="")
if (!dir.exists(PFX_Dir)){dir.create(PFX_Dir)}
if (!dir.exists(PFX_Dir_Dist)){dir.create(PFX_Dir_Dist)}
if (!dir.exists(PFX_Dir_Mapping)){dir.create(PFX_Dir_Mapping)}
if (!dir.exists(PFX_Dir_MapGraph)){dir.create(PFX_Dir_MapGraph)}
if (!dir.exists(PFX_Dir_Crosses)){dir.create(PFX_Dir_Crosses)}

# Get PB-FB-X neuron synapse locations per layer
PFX_SynsAll=subset(FBC_SynsAll, !(is.na(PBglom)) & startsWith(type,"PF"))
PFX_Distribution=Get_SynLayerDistribution(PFX_SynsAll, 25, PFX_Dir_Dist) # 25 is good here, as some types have low synapse counts


# Make plotting directory
D0_Dir=paste(PlotDir,"D0_Plots_All","/",sep="")
D0_Dir_Dist=paste(D0_Dir,"D0_MeasureWidth","/",sep="")
if (!dir.exists(D0_Dir)){dir.create(D0_Dir)}
if (!dir.exists(D0_Dir_Dist)){dir.create(D0_Dir_Dist)}

# Get Delta0 neuron synapse locations per layer
D0_SynsAll=subset(FBC_SynsAll, startsWith(type,"Delta0") & !startsWith(bodyname,"Delta12"))
D0_Distribution=Get_SynLayerDistribution(D0_SynsAll, 25, D0_Dir_Dist) # 25 is good here, as some types have low synapse counts


```



# Subset PFX_Distribution and D0_Distribution by layers that contain all neurons of the population type
```{r}

# Subaet PFX data to include only layers innervated by all neurons of a type
PFX_NamedBodies=subset(NamedBodies, startsWith(bodytype,"PF")) 
PFX_NeuronsPerType = PFX_NamedBodies %>% group_by(bodytype) %>% summarise(NeuronsPerType=n())
colnames(PFX_NeuronsPerType)[1]="type"
PFX_NeuronsOfTypePerLayer= PFX_Distribution %>% group_by(type, Layer) %>% summarise(NeuronsPerLayer=n())
PFX_NeuronsOfTypePerLayer=merge(PFX_NeuronsOfTypePerLayer, PFX_NeuronsPerType)
PFX_NeuronsOfTypePerLayer$PercentInLayer=PFX_NeuronsOfTypePerLayer$NeuronsPerLayer/PFX_NeuronsOfTypePerLayer$NeuronsPerType*100 
PFX_NeuronsOfTypePerLayer = subset(PFX_NeuronsOfTypePerLayer, PercentInLayer>90) #PFNp_a has less than 100- 4 bodies dont innervate pb glom. PFNp_b has one neuron missing.
PFX_Distribution_Filt=inner_join(PFX_Distribution, PFX_NeuronsOfTypePerLayer, by = c("type","Layer"))
remove(PFX_Distribution)

# Subaet D0 data to include only layers innervated by all neurons of a type


```



# Assign the PB-FB-XX and Delta0 neurons to columns defined by the closet FX column for each layer.
# Plot the PB-FB glomerulus->column pattern for each PB-FB-XX neuron
```{r}


library(ggraph)
library(igraph)
library(tidygraph)
source("FB_SynapseDistribution_Utils.R")


# Assign column names based on closest neuron
PFX_Distribution_Columns = Assign_FB_Columns(PFX_Distribution_Filt, FX_Distribution_Filt, PFX_Dir_Mapping)
PFX_Distribution_Columns$PBglom = factor(PFX_Distribution_Columns$PBglom, levels= c("L9","L8","L7","L6","L5","L4","L3","L2","L1",
                                                                    "R1","R2","R3","R4","R5","R6","R7","R8","R9")) 
remove(PFX_Distribution_Filt)

# Get number of neurons going from each glom to each column
PFX_GlomToColumn_All=PFX_Distribution_Columns %>% group_by(bodyid, type, PBglom, FBcol) %>% summarise(Num_layers = n(), FBcol_Con= mean(FBcol_Con))
PFX_GlomToColumn_All=PFX_GlomToColumn_All %>% group_by(type, PBglom, FBcol) %>% summarise(Num_Neurons = n(), FBcol_Con= mean(FBcol_Con))



# Plot PB->FB mapping as a graph
Plot_PBglom_FBcol_Mapping(PFX_GlomToColumn_All, PFX_Dir_MapGraph, "ALL")


# Manually update mappings to correct what we think are errors
PFX_GlomToColumn_Sym=PFX_GlomToColumn_All
UpdateMapping=data.frame(type = character(), PBglom =  character(), FBcol=  character(), FBcol_New =  character() )
UpdateMapping=rbind(UpdateMapping,
                    data.frame(type = "PFGs", PBglom = "L8", FBcol= "C9", FBcol_New = "C8" ),
                    data.frame(type = "PFGs", PBglom = "L7", FBcol= "C8", FBcol_New = "C7" ),
                    data.frame(type = "PFL1", PBglom = "R6", FBcol= "C2", FBcol_New = "C3" ),
                    data.frame(type = "PFL1", PBglom = "R5", FBcol= "C3", FBcol_New = "C4" ),
                    data.frame(type = "PFNa", PBglom = "L7", FBcol= "C7", FBcol_New = "C6" ),
                    data.frame(type = "PFNd", PBglom = "R8", FBcol= "C3", FBcol_New = "C2" ),
                    data.frame(type = "PFNd", PBglom = "L5", FBcol= "C5", FBcol_New = "C4" ),
                    data.frame(type = "PFNp_a", PBglom = "L4", FBcol= "C4", FBcol_New = "C3" ),
                    data.frame(type = "PFNp_a", PBglom = "L3", FBcol= "C1", FBcol_New = "C2" ),
                    data.frame(type = "PFNp_c", PBglom = "L9", FBcol= "C8", FBcol_New = "C9" ),
                    data.frame(type = "PFR_a", PBglom = "L8", FBcol= "C9", FBcol_New = "C8" ),
                    data.frame(type = "PFNp_b", PBglom = "R2", FBcol= "C8", FBcol_New = "C9"),
                    data.frame(type = "PFNp_b", PBglom = "L6", FBcol= "C6", FBcol_New = "C5"),
                    data.frame(type = "PFL3", PBglom = "L3", FBcol= "C6", FBcol_New = "C5" ),
                    data.frame(type = "PFL3", PBglom = "R1", FBcol= "C8", FBcol_New = "C7" ))



# Create new mapping with corrections from UpdateMapping  
N_Count=0
for (rrr in 1:length(UpdateMapping$type)){
  Row_Ind=which(as.character(PFX_GlomToColumn_Sym$type) == as.character(UpdateMapping$type[rrr]) &
                as.character(PFX_GlomToColumn_Sym$PBglom) == as.character(UpdateMapping$PBglom[rrr]) &
                as.character(PFX_GlomToColumn_Sym$FBcol) == as.character(UpdateMapping$FBcol[rrr]) )
  PFX_GlomToColumn_Sym$FBcol[Row_Ind] = as.character(UpdateMapping$FBcol_New[rrr])
  N_Count=N_Count+length(Row_Ind)
}
PFX_GlomToColumn_Sym = PFX_GlomToColumn_Sym %>% group_by(type, PBglom, FBcol) %>% summarise(Num_Neurons = sum(Num_Neurons),  FBcol_Con = mean(FBcol_Con))

# Plot NEW PB->FB mapping as a graph
Plot_PBglom_FBcol_Mapping(PFX_GlomToColumn_Sym, PFX_Dir_MapGraph, "SYM")

# Get number of neurons mapped from glom to cols
PFX_NeuonrsPerTypeWithMappings=PFX_GlomToColumn_All %>% group_by(type) %>% summarize(Num = sum(Num_Neurons))


```



# Now that we have the columns (in PFX_Distribution_Columns), assign them to PFX_SynsAll and plot the crosses
```{r}


# Get subset of mapping information
PFX_Distribution_Columns_Mapping=PFX_Distribution_Columns[c("bodyid","PBglom","FBcol")]


# Update PFX_SynsAll
Temp_ColNames=colnames(PFX_SynsAll)
PFX_SynsAll=PFX_SynsAll[!colnames(PFX_SynsAll)=="FBcol"]
PFX_SynsAll=inner_join(PFX_SynsAll, PFX_Distribution_Columns_Mapping, by=c("bodyid","PBglom"))
PFX_SynsAll=PFX_SynsAll[Temp_ColNames]


# Get average X/Z position of each column in each layer
PFX_Column_Positions = as.data.frame(PFX_Distribution_Columns %>% group_by(FBcol, Layer, type) %>% 
                                      summarise(X_Mean = mean(X_Mean), Y_Mean=mean(Y_Mean), Z_Mean = mean(Z_Mean),
                                                Cross_XL_X = mean(Cross_XL_X), Cross_XL_Z = mean(Cross_XL_Z),
                                                Cross_XR_X = mean(Cross_XR_X), Cross_XR_Z = mean(Cross_XR_Z),
                                                Cross_YU_X = mean(Cross_YU_X), Cross_YU_Z = mean(Cross_YU_Z),
                                                Cross_YD_X = mean(Cross_YD_X), Cross_YD_Z = mean(Cross_YD_Z)))


# Plot the distribution of PB-FB-XX column positions for all neurons and each type individually 
PlotColumn_Aves(PFX_Column_Positions, "PFX_Columns_All", PFX_Dir_Crosses, FALSE)
PlotColumn_Types(PFX_Column_Positions, "PFX_Columns", PFX_Dir_Crosses, FALSE) 

# Save entire workspace to file
save.image(file=paste(SaveDir,'All_Data.Rdata',sep=""))



```




# Plot connectivity to of PB-FB-XX neurons to check for offsets 
```{r}


source("InputOutputByTypeUtils.R")
source("neuprintQueryUtils.R")
source("visualizeConnectivityTables.R")
library("xlsx")

# Get input and output tables
PFX_Types=unique(PFX_NeuronsPerType$type)
PFX_Bag=buildInputsOutputsByType(PFX_Types, slctROI="FB")
PFX_FB_Outputs_All=PFX_Bag[["outputs_raw"]]
PFX_FB_Inputs_All=PFX_Bag[["inputs_raw"]]


# Get FB columns and PB glomeruli 
All_FX_PFX=rbind(FX_SynsAll,PFX_SynsAll)
Glom_And_Col=All_FX_PFX
Glom_And_Col=distinct(Glom_And_Col[c("bodyid","Side","PBglom","FBcol")])
Glom_And_Col_From=Glom_And_Col
colnames(Glom_And_Col_From)= c("from","Side.from","PBglom.from","FBcol.from")
Glom_And_Col_To=Glom_And_Col
colnames(Glom_And_Col_To)= c("to","Side.to","PBglom.to","FBcol.to")


## Get mapping in compact form and save as file to share (this needs to go somewhere else)
PB_To_FB_Map=distinct(All_FX_PFX[c("bodyid","type","bodyname","Side","PBglom","FBcol")])
save(PB_To_FB_Map, file = paste(SaveDir,"PB_To_FB_Map.Rdata",sep=""))
PB_To_FB_Map_PbFbXx=distinct(PFX_SynsAll[c("bodyid","type","bodyname","Side","PBglom","FBcol")])
PB_To_FB_Map_PbFbXx=PB_To_FB_Map_PbFbXx[order(PB_To_FB_Map_PbFbXx$type),]
PB_To_FB_Map_PbFbXx$bodyname_new=paste(PB_To_FB_Map_PbFbXx$bodyname, "_", PB_To_FB_Map_PbFbXx$FBcol, sep="")
write.xlsx(PB_To_FB_Map_PbFbXx,  paste(SaveDir,"PB_To_FB_Map.xlsx",sep=""), sheetName = "Sheet1", col.names = TRUE, row.names = TRUE, append = FALSE)


# Add column, glomerlus, and side information to inputs/output tables
PFX_FB_Outputs=merge(PFX_FB_Outputs_All, Glom_And_Col_From, by="from", all.x=TRUE)
PFX_FB_Outputs=merge(PFX_FB_Outputs, Glom_And_Col_To, by="to", all.x=TRUE)
PFX_FB_Inputs=merge(PFX_FB_Inputs_All, Glom_And_Col_From, by="from", all.x=TRUE)
PFX_FB_Inputs=merge(PFX_FB_Inputs, Glom_And_Col_To, by="to", all.x=TRUE)


# Order input table
PFX_FB_Inputs$PBglom.to=factor(PFX_FB_Inputs$PBglom.to, levels = rev(c("R9","L1","R8","L2","R7","L3","R6","L4","R5","L5","R4","L6","R3","L7","R2","L8","R1","L9")))
PFX_FB_Inputs$FBcol.from=factor(PFX_FB_Inputs$FBcol.from, levels = rev(c("C9","C8","C7","C6","C5","C4","C3","C2","C1")))
PFX_FB_Inputs$name.from=factor(PFX_FB_Inputs$name.from, levels = unique((PFX_FB_Inputs$name.from)[order(PFX_FB_Inputs$FBcol.from)]) )
PFX_FB_Inputs$name.to=factor(PFX_FB_Inputs$name.to, levels = unique((PFX_FB_Inputs$name.to)[order(PFX_FB_Inputs$FBcol.to)]) )


# Order ouput table
PFX_FB_Outputs$PBglom.from=factor(PFX_FB_Outputs$PBglom.from, levels = rev(c("R9","L1","R8","L2","R7","L3","R6","L4","R5","L5","R4","L6","R3","L7","R2","L8","R1","L9")))
PFX_FB_Outputs$FBcol.to=factor(PFX_FB_Outputs$FBcol.to, levels = rev(c("C9","C8","C7","C6","C5","C4","C3","C2","C1")))
PFX_FB_Outputs$name.to=factor(PFX_FB_Outputs$name.to, levels = unique((PFX_FB_Outputs$name.to)[order(PFX_FB_Outputs$FBcol.to)]) )
PFX_FB_Outputs$name.from=factor(PFX_FB_Outputs$name.from, levels = unique((PFX_FB_Outputs$name.from)[order(PFX_FB_Outputs$FBcol.from)]) )

# Create output folder
PFX_Dir_Connectivity=paste(PFX_Dir,"PFX_ConnectivityOffsets","/",sep="")
if (!dir.exists(PFX_Dir_Connectivity)){dir.create(PFX_Dir_Connectivity)}


for (nnn in 1:length(PFX_Types)){
  Temp_Type=PFX_Types[nnn]

    
  # Output table for this neuron
  Temp_OutputTable=subset(PFX_FB_Outputs, databaseType.from == Temp_Type)
  Temp_OutputTable=subset(Temp_OutputTable, type.to %in% unique(All_FX_PFX$type))  

  # Filter output table by neuron types that innervate all columns
  Temp_GoodTypes_Output=Temp_OutputTable %>% group_by(FBcol.to, type.to) %>% summarize(n=n()) %>% group_by(type.to) %>% summarize(NumOfCol=n())
  Temp_GoodTypes_Output=subset(Temp_GoodTypes_Output, NumOfCol==9)
  Temp_OutputTable=subset(Temp_OutputTable, type.to %in% Temp_GoodTypes_Output$type.to & !is.na(FBcol.to) & !is.na(PBglom.from))
  
  # Compute mean by input/output cell type and input PBglom and output FBcol
  Temp_OutputTable_Sum=Temp_OutputTable %>% group_by(type.from, type.to, PBglom.from, FBcol.to) %>% summarise(weight=mean(weight))
  
  # Make output plots  
  if (length(Temp_OutputTable$weight)>0){
   
    # Plot all matrices
    OutputsPlot = plotConnectivityMatrix(Temp_OutputTable_Sum, byGroup = "Glom_to_Col", connectionMeasure = "weight")
    OutputsPlot = OutputsPlot + facet_grid(reorder(type.from, desc(type.from)) ~ type.to, switch="both") + 
      ggtitle(paste("Outputs from ", Temp_Type, " in FB")) +  coord_fixed(ratio = 1) 
    ggsave(paste(PFX_Dir_Connectivity, Temp_Type,"_Outputs_inFB.png",sep=""),
           plot = OutputsPlot, device='png', scale = 1, width = 10, height = 10, units ="in", dpi = 500, limitsize = TRUE)
    
    # Plot matrices one-by-one for each downstream cell type
    Temp_Downstream_Types=unique(Temp_OutputTable_Sum$type.to)
    for (ttt in 1:length(Temp_Downstream_Types)){
      Temp_OutputTable_Sum_Subset=subset(Temp_OutputTable_Sum, type.to == Temp_Downstream_Types[ttt])
      
      OutputsPlot_Sub = plotConnectivityMatrix(Temp_OutputTable_Sum_Subset, byGroup = "Glom_to_Col", connectionMeasure = "weight")
      OutputsPlot_Sub = OutputsPlot_Sub + facet_grid(reorder(type.from, desc(type.from)) ~ type.to, switch="both") + 
        ggtitle(paste("Outputs from ", Temp_Type, " in FB")) +  coord_fixed(ratio = 1) 
      ggsave(paste(PFX_Dir_Connectivity, Temp_Type,"_OutoutTo_", Temp_Downstream_Types[ttt], "_inFB.png",sep=""),
             plot = OutputsPlot_Sub, device='png', scale = 1, width = 4, height = 5, units ="in", dpi = 500, limitsize = TRUE)
    }
    
  }
  
  
  
  # Inpute table for this neuron
  Temp_InputTable=subset(PFX_FB_Inputs, databaseType.to == Temp_Type)
  Temp_InputTable=subset(Temp_InputTable, type.from %in% unique(All_FX_PFX$type)) 
  
  # Filter input table by neuron types that innervate all columns
  Temp_GoodTypes_Input=Temp_InputTable %>% group_by(FBcol.from, type.from) %>% summarize(n=n()) %>% group_by(type.from) %>% summarize(NumOfCol=n())
  Temp_GoodTypes_Input=subset(Temp_GoodTypes_Input, NumOfCol==9)
  Temp_InputTable=subset(Temp_InputTable, type.from %in% Temp_GoodTypes_Input$type.from & !is.na(FBcol.from) &  !is.na(PBglom.to))

  # Compute mean by input/output cell type and input PBglom and output FBcol
  Temp_InputTable_Sum=Temp_InputTable %>% group_by(type.from, type.to, PBglom.to, FBcol.from) %>% summarise(weight=mean(weight))
  
  # Make input plots  
  if (length(Temp_InputTable$weight)>0){
    InputsPlot = plotConnectivityMatrix(Temp_InputTable_Sum, byGroup = "Col_to_Glom", connectionMeasure = "weight")
    InputsPlot = InputsPlot + facet_grid(reorder(type.from, desc(type.from)) ~ type.to, switch="both") +
      ggtitle(paste("Inputs to ", Temp_Type, " in FB")) +  coord_fixed(ratio = 1) 
    ggsave(paste(PFX_Dir_Connectivity, Temp_Type,"_Inputs_inFB.png",sep=""),
           plot = InputsPlot, device='png', scale = 1, width = 10, height = 10, units ="in", dpi = 500, limitsize = TRUE)
    
    # Plot matrices one-by-one for each upstream cell type
    Temp_Upstream_Types=unique(Temp_InputTable_Sum$type.from)
    for (ttt in 1:length(Temp_Upstream_Types)){
      Temp_InputTable_Sum_Subset=subset(Temp_InputTable_Sum, type.from == Temp_Upstream_Types[ttt])
      
      InputsPlot_Sub = plotConnectivityMatrix(Temp_InputTable_Sum_Subset, byGroup = "Col_to_Glom", connectionMeasure = "weight")
      InputsPlot_Sub = InputsPlot_Sub + facet_grid(reorder(type.from, desc(type.from)) ~ type.to, switch="both") + 
        ggtitle(paste("Inputs to ", Temp_Type, " in FB")) +  coord_fixed(ratio = 1) 
      ggsave(paste(PFX_Dir_Connectivity, Temp_Type,"_InputFrom_", Temp_Upstream_Types[ttt], "_inFB.png",sep=""),
             plot = InputsPlot_Sub, device='png', scale = 1, width = 7.5, height = 5, units ="in", dpi = 500, limitsize = TRUE)
    }
    
  }
  
}


  
  




```



# Look for lateralized output patterns, where PB-FB-XX neurons from right bridge target neurons that neurons from left bridge do not
```{r}


# Make directory
PFX_Dir_Lat=paste(PFX_Dir,"PFX_Left_VS_Right","/",sep="")
if (!dir.exists(PFX_Dir_Lat)){dir.create(PFX_Dir_Lat)}


# Plot all outputs and look for lateralization
PFX_FB_Outputs_Lat=subset(PFX_FB_Outputs, startsWith(type.to, "Delta" ) & !type.to=="Delta?" & !is.na(PBglom.from))
PFX_FB_Outputs_Lat$to=as.character(PFX_FB_Outputs_Lat$to)
PFX_FB_Outputs_Lat$from=as.character(PFX_FB_Outputs_Lat$from)

# Get upstream and downstream types
UpTypes   = unique(PFX_FB_Outputs_Lat$type.from)
DownTypes = unique(PFX_FB_Outputs_Lat$type.to)

# Get the total number of cells for all upstream and downstream types
Number_of_Ups= subset(NamedBodies, bodytype %in% UpTypes) %>% group_by(bodytype) %>% summarize(N=n())
Number_of_Downs= subset(NamedBodies, bodytype %in% DownTypes) %>% group_by(bodytype) %>% summarize(N=n())


# Loop over all upstream/downstream pairs and plot matricies
for (upup in 1:length(UpTypes)){
  for (downdown in 1:length(DownTypes)){
    
    # Get connectivity matrix from upstream type to downstream type
    Temp_Lat=subset(PFX_FB_Outputs_Lat, type.from == UpTypes[upup] & type.to == DownTypes[downdown] & weight>3) 
    
    if (length(Temp_Lat$to>0)){
      # Get number of upstream/downstream neurons as a percent of the total
      Temp_TotalUps=Number_of_Ups[Number_of_Ups$bodytype == UpTypes[upup],]$N
      Temp_TotalDowns=Number_of_Downs[Number_of_Downs$bodytype == DownTypes[downdown],]$N
      Temp_NowUps=length(unique(subset(Temp_Lat, type.from == UpTypes[upup] )$from))
      Temp_NowDowns=length(unique(subset(Temp_Lat, type.to == DownTypes[downdown] )$to))
      
      # Average by PB glom
      Temp_Lat_Sum=Temp_Lat %>% group_by(PBglom.from, Side.from, to, name.to) %>% summarize(weight = mean(weight))
      
      
      
      if (Temp_NowUps/Temp_TotalUps>0.35 & Temp_NowDowns/Temp_TotalDowns >0.35){
        
        PP <- ggplot(Temp_Lat_Sum) + 
          theme_classic() + theme(axis.text.x = element_text(angle = 90)) +
          scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                               midpoint =0.5*max(Temp_Lat_Sum$weight), limits=c(0,max(Temp_Lat_Sum$weight))) +
          geom_tile(aes(to,PBglom.from,fill=weight)) +
          facet_grid(rows = vars(Side.from), scales="free_y") +
          ggtitle(paste(Temp_Lat$type.from[1]," to ",Temp_Lat$type.to[1],sep=""))
        
        ggsave(paste(PFX_Dir_Lat, Temp_Lat$type.from[1],"_to_",Temp_Lat$type.to[1], "_inFB.png",sep=""),
               plot = PP, device='png', scale = 1, width = 7.5, height = 5, units ="in", dpi = 500, limitsize = TRUE)
      }
    }
  }
}
















```


















