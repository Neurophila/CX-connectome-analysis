---
title: "Illustration of tools for analysing connectivity between neurons within a region"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(dplyr)
options(nat.plotengine = 'rgl')
```

```{r}
neuprint_login()
```

```{r, messages=FALSE, warning=FALSE}
# Get some custom functions
source("neuprintQueryUtils.R")
source("visualizeConnectivityTables.R")

# To be able to use ? for accessing doc strings in custom functions, please install the "docstring" package. Alternatively use docstring(function)
library(docstring)
```


### Make selection of neurons to be used in connecitivy analysis
```{r}
postNeuron = "PFN"#c("LN1", "LN2", "LN3", "LNa", "LCNp", "LCNpm")  #
postName = "PFNs"#"PFN inputs"#
postIDs = getBodyIdsForList(postNeuron)

########
preName = paste0(postName," partners")
saveName = paste0(postName,"inputs")

ROI = "NO"#"LAL"
slctROI = "NO"#"LAL(R)"
```

***Select valid partners in ROI***
This should be done based on some broadly used criteria. Alternatively, one could read in previously curated lists of neurons.
```{r}
useCuratedList = FALSE

if (useCuratedList) {
  # load list
  load(paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/",ROI,"/",ROI,"_Types.RData"))
  # do something
} else{

  synCutoff = 3
  relWeightCutoff = .01 # percent input or output in that region
  relWeightROICutoff = .01 # percent total input
  
  # get all connections
  myConnections = getConnectionTable(postIDs$bodyid, "PRE", slctROI)
  
  # find relevant partners
  partnersInRoi =  myConnections %>% 
    filter(ROIweight > synCutoff)  %>% # minimum number of synapses in ROI for a given connection
    group_by(type) %>% 
    filter( (weightRelative >= relWeightCutoff) & (weightROIRelativeTotal >=  relWeightROICutoff) )
  partnersInRoi = unique(partnersInRoi$partnerType) 

}
ggplot(myConnections %>% filter(partnerType %in% partnersInRoi), aes(x=partnerType, fill=partnerType)) + geom_bar() + theme_classic() + 
  theme(axis.text.x = element_text(angle = 90)) + guides(fill=FALSE)
```

```{r}
# Why we need to use ROI weight...
#pfnv_skel = neuprint_read_neuron(neuprint_search("PFNv.*_L.*")$bodyid[1])
#lalmesh = neuprint_ROI_mesh("LAL(R)")
#plot3d(pfnv_skel)
#plot3d(lalmesh, alpha=0.5, add=TRUE)
```

### Get connectivity table
```{r, warning=FALSE}
preNeuron = partnersInRoi
preIDs = getBodyIdsForList(preNeuron)
myConnections = getConnectionTable_forSubset(preIDs$bodyid,postIDs$bodyid, slctROI)
```

### Connectivity matrix
```{r}
source("visualizeConnectivityTables.R")

conMatPlot = plotConnectivityMatrix(myConnections, byType = TRUE)
conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI)
print(conMatPlot)
ggsave( paste("connectivityMatrix_",saveName,'_in_',slctROI,'.pdf', sep=''), plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
  scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)

conMatPlot = plotConnectivityMatrix(myConnections, byType = FALSE)
conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI)
conMatPlot = structureMatrixPlotByType(conMatPlot)
print(conMatPlot)
ggsave(paste("connectivityMatrix_",saveName,'_in_',slctROI,'_byID.pdf', sep=''), plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
  scale = 2, width = 25, height =16, units ="cm", dpi = 600, limitsize = TRUE)
```

###  Draw graph
```{r, warning=FALSE}
connectData = data.frame(from = myConnections$bodyid,
                       to = myConnections$partner,
                       type.from = myConnections$type,
                       type.to = myConnections$partnerType,
                       weight = myConnections$ROIweight) %>%
  mutate(status = neuprint_get_meta(to)$status,
         pre = neuprint_get_meta(to)$pre,
         post = neuprint_get_meta(to)$post,
         relWeight = 100*weight/neuprint_get_meta(to)$post)
```

# TODO use tidygraph...


```{r, warning=FALSE}
require(igraph)
source("colorCodeLookup.R")

cutoff = 1 # in  %
#Reroganize to make graph with types instead of bodyids
graphData = reorganizeGraphData(connectData$type.from,
                                connectData$type.to,
                                connectData$relWeight,cutoff)
nodes = getGraphNodes(graphData)

nodeCols = colors()[seq(1, length(nodes))]
simpleTypesNodes = getSimpleTypeNames(nodes)

#tryCatch(){...}
for (i in seq(1, length(simpleTypesNodes))) {
  nodeCols[i] = colors()[colorValueLookup$col[colorValueLookup$type == simpleTypesNodes[i]]]
}
  
graphData_noSelf = getNoSelfGraphData(graphData)
graphData_selfFB = getSelfFBGraphData(graphData)

myGraph = constructConnectivityGraph(nodes, graphData_noSelf, graphData_selfFB, cutoff,7,.3, 2, nodeCols)
l = layout_with_fr(myGraph)
plot(myGraph,edge.curved=0.5, layout=l, edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap #edge.color=edge.col,

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_minPostWeight",cutoff,".pdf"), width=10, height=10)


```


### Illustration of other graph analyses 
```{r}
hs <- hub_score(myGraph, weights=NA)$vector
as <- authority_score(myGraph, weights=NA)$vector

par(mfrow=c(1,2))
plot(myGraph, vertex.size=hs*40, main="Hubs", layout = l)
plot(myGraph, vertex.size=as*40, main="Authorities", layout = l)

```
```{r}
cfg <- cluster_edge_betweenness(as.undirected(myGraph))
#plot(cfg, as.undirected(connectGraph))

V(myGraph)$community <- cfg$membership
colrs <- adjustcolor( c("seagreen", "orange", "tomato",  "gold", "plum","yellowgreen","cyan"), alpha=.6)
plot(myGraph, vertex.color=colrs[V(myGraph)$community])
```

```{r}
deg <- degree(myGraph, mode="all")
deg.dist <- degree_distribution(myGraph, cumulative=T, mode="all")
plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange",
      xlab="Degree", ylab="Cumulative Frequency")
```



### Experimenting with new connectivity table query
```{r}
roiHierarchy = neuprint_ROI_hierarchy()
myConnections2 = getConnectionTable(postIDs$bodyid, "PRE", by.roi = TRUE) %>% 
  mutate(parentRoi = roi %in% roiHierarchy$parent)
```

Filter out connections with that are irrelavant
```{r}
synCutoff = 3
relWeightCutoff = 0.1 # percent input or output in that region
relWeightROICutoff = 0.01 # percent total input

# find relevant partners
myConnections3 <- myConnections2 %>% filter(parentRoi == FALSE)

myConnections3 <-  myConnections3 %>% 
  filter(ROIweight > synCutoff)  %>% # minimum number of synapses in ROI for a given connection
  group_by(type) %>% 
  filter( (weightRelative >= relWeightCutoff) & (weightROIRelativeTotal >=  relWeightROICutoff) )
```

```{r}
countsPerRegion <- myConnections3 %>% group_by(type, roi) %>% 
      summarise(meanTotalROIweight = mean(totalROIweight),
                meanROIweight = mean(ROIweight),
                npartnerTypes = length(unique(partnerType)),
                npartners = length(unique(partner)),
                partnersRatio = length(unique(partner))/length(unique(bodyid)))
head(countsPerRegion)
```
```{r}
ggplot(countsPerRegion, aes(x=roi, y=type, size=meanTotalROIweight, color=meanROIweight)) + 
  geom_point() +
  #facet_grid(name ~ prepost, space="free", scales="free", switch="y") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90)) #+ guides(color=FALSE) +
  #theme(axis.text.y = element_blank(),strip.placement = "outside", strip.background = element_rect(fill=NA, colour="grey50")) 

ggplot(countsPerRegion, aes(x=roi, y=type, size=partnersRatio, color=npartnerTypes)) + 
  geom_point() +
  #facet_grid(name ~ prepost, space="free", scales="free", switch="y") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90)) #+ guides(color=FALSE) +
  #theme(axis.text.y = element_blank(),strip.placement = "outside", strip.background = element_rect(fill=NA, colour="grey50")) 
```

