---
title: "Tools for analysing connectivity between neurons within a region"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(dplyr)
library(neuprintrExtra)
options(nat.plotengine = 'rgl')
library(igraph)

neuprint_login()
```

```{r, messages=FALSE, warning=FALSE}
# Get some custom functions
source("visualizeConnectivityTables.R")

# To be able to use ? for accessing doc strings in custom functions, please install the "docstring" package. Alternatively use docstring(function)
#library(docstring)

getBodyIdsForList = function (neuronList,prefix="",postfix=".*",...){
  #' Get one dataframe of bodyIDs for all search strings in neuronList
  #' @param neuronList: A list of search strings to be passed.
  #' @param prefix: String to be added before each query (default "")
  #' @param postfix: String to be added after each query (default ".*")
  #' @param ...: Parameters to be passed to neuprint_search. Note that meta=FALSE won't work for now.
  #' @return A data frame of metadata for the results of all the queries
  #' @examples
  #' \dontrun{
  #' # Both will return the same
  #' getBodyIdsForList(c("PFL1","PFL2"))
  #' getBodyIdsForList(c("PFL1","PFL2"),postfix="",field="type")
  #' }
  
  neuronList <-  paste0(prefix,neuronList,postfix)
  bodiesList <- lapply(neuronList,neuprint_search,...)
  return(bind_rows(bodiesList))
}
```


### Make selection of neurons to be used in connecitivy analysis
This should be done based on some broadly used criteria. Alternatively, one could read in previously curated lists of neurons.
```{r}
ROI = "AOTU"
slctROI ="AOTU(R)"# "EB"#LAL(-GA)

splitLR = TRUE

saveName = paste0("allIn",slctROI) #RN_TB_ExR #RN_ExR_col_in_
if(splitLR){saveName = paste0(saveName,"_LR")}

useCuratedListPost = FALSE#
useCuratedListPre = FALSE#
curatedList = paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/",ROI,"/",ROI,"_Types.RData")

#only relevant if one of the above is false:
useCustomPostSelection = TRUE
useCustomPreSelection = FALSE
usenbag = TRUE
inCX = FALSE

if(!useCustomPostSelection & !useCustomPreSelection){
  if(splitLR){
    roiTable = getTypesInRoiTable(slctROI,lateralize = TRUE, minTypePercentage = 0.5)
  }else{
    roiTable = getTypesInRoiTable(slctROI,lateralize = FALSE,minTypePercentage = 0.5)
  }
}

# filter based on what is in Shin-ya's CX neuron list
CXneuronList = read.csv("CX-cell-types060920.csv")
```


***Selection of neurons***
```{r}
# POST

if (useCuratedListPost) {
  # load list
  load(curatedList)
  
  # select neurons from there
  postNeuron = get(paste0(ROI,"_Type"))
  postNeuron <- gsub("\\(.*\\)", "", postNeuron)
  postName = paste0(ROI, " neurons")
  
  postIDs = getBodyIdsForList(postNeuron, field="type")
  
} else{
  if(useCustomPostSelection){
    postNeuron = c("TuBu")#c(paste0("ER",seq(6)))
    postNeuron = paste0(postNeuron,".*")
    #c(paste0("ER",seq(6)))
    #c("EL", "ExR", "PEG","AVM08n","EPG")
    #c("ExR.*","PDM21a.*","TuBu.*","R1.*","R2.*","R3.*","R4.*","R5.*","R6.*")
    #c("EL","EPG","EPGt","PEG","PEN_a","PEN_b")#
    #, "ExR","EPG","EL","EPGt","PEG","PEN","PEN") #c("PDM21a.*","TuBu.*", "TuTuB.*")# 
    postName = paste0("Columnar in ",slctROI) #RN, columnar and ExR
    postIDs = getBodyIdsForList(postNeuron)
    if(inCX){
      postIDs = postIDs %>% filter(type %in% CXneuronList$n.type)
    }
  }else{
    postName = paste0("all in ", ROI)
    postIDs = roiTable$names
    postIDs = postIDs %>% filter(databaseType %in% CXneuronList$n.type)
  }
}

# PRE
if (useCuratedListPre) {
  # load list
  load(curatedList)
  
  # select neurons from there
  preNeuron = get(paste0(ROI,"_Type"))
  preNeuron <- gsub("\\(.*\\)", "", preNeuron)
  preIDs = getBodyIdsForList(preNeuron, field="type")
  preName = paste0(ROI, "neurons")

} else{
  if(useCustomPreSelection){
    preNeuron = postNeuron#c(paste0("ER",seq(6)))#postNeuron #c("TuBu.*")#
    preName = postName#paste0("TB in ",slctROI) # 
    preIDs = getBodyIdsForList(preNeuron)
    preIDs = preIDs %>% filter(type %in% CXneuronList$n.type)
  }else{
    if(usenbag){
      nbag = create_neuronBag(postIDs)
      preIDs = nbag$inputs %>% filter(roi == slctROI) %>% select(type.from) %>% unique()
      preIDs = getBodyIdsForList(preIDs$type.from , field="type")
      preName = paste0("all ", ROI)
    }else{
      preName = paste0("all ", ROI)
      preIDs = roiTable$names
      if(inCX){
        preIDs = preIDs %>% filter(databaseType %in% CXneuronList$n.type)
      }
    }
  }
}
```


### Get connectivity table
```{r, warning=FALSE}
preTypes = c(preIDs$bodyid, postIDs$bodyid) # preIDs$bodyid
postTypes = preTypes#postIDs$bodyid
myConnections = getConnectionTable(preTypes, "POST", slctROI)
myConnections = myConnections %>% filter(to %in% postTypes) 
  
#write.csv(myConnections, paste0("../neuprintR_analysis_plots/connectivityTable_",saveName,'_byid.csv'), row.names = FALSE)
```

```{r}
typesTable <- getTypesTable(unique(myConnections$databaseType.to))

if (splitLR){
  # Subdivide types and build a custom types table
  myConnections = lateralize_types(myConnections, postfix="to")
  myConnections = lateralize_types(myConnections, postfix="from")
  typesTable = lateralize_types(typesTable, postfix="raw")
}

myConnectionsT2T = getTypeToTypeTable(myConnections,typesTable = typesTable)
```

```{r}
myConnections_nameid = myConnections %>% mutate(typeid.to = paste(type.to, to,sep="_"),
                                                typeid.from = paste(type.from, from, sep="_"))
edge_list <- myConnections_nameid[c("from","to","weightRelative")]
#[c("typeid.from","typeid.to","weightRelative")]
#G <- graph.data.frame(edge_list,directed=TRUE);
#A <- as_adjacency_matrix(G,type="both",names=TRUE,sparse=FALSE,attr="weightRelative")
#write.csv(A, paste0("../neuprintR_analysis_plots/adjacencyMatrix_",saveName,'_byid.csv'), row.names = FALSE)
#write.csv(edge_list, paste0("../neuprintR_analysis_plots/edgeList_",saveName,'_byid.csv'), row.names = FALSE)

```


### Connectivity matrix
```{r}
plotW = 25# 45 # 20
plotH = 21 #4 #40  #17
cmax = NULL
connectionMeasures = c("weightRelative")

for (connectionMeasure in connectionMeasures){
  
  conMatPlot = plotConnectivityMatrix(myConnectionsT2T, byGroup = "type", connectionMeasure, cmax)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  
  print(conMatPlot)
  ggsave( paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'_byType.pdf', sep=''), plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
    scale = 1.5, width = plotW*0.8, height = plotH*0.8, units ="cm", dpi = 600, limitsize = TRUE)
  
  conMatPlot = plotConnectivityMatrix(myConnections, byGroup = "name", connectionMeasure,cmax)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  #conMatPlot = structureMatrixPlotByType(conMatPlot)
  #print(conMatPlot)
  #ggsave( paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'_byName.pdf', sep=''), 
  #  plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
  #    scale = 1.5, width = plotW*0.8, height = plotH*0.8, units ="cm", dpi = 600, limitsize = TRUE)
  
  conMatPlot = plotConnectivityMatrix(myConnections, byGroup = "id", connectionMeasure, cmax)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  conMatPlot = structureMatrixPlotByType_lines(conMatPlot)
  print(conMatPlot)
  ggsave(paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'_byID.pdf', sep=''), 
    plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
    scale = 2, width = plotW, height =plotH, units ="cm", dpi = 600, limitsize = TRUE)
}
```


###  Draw graph

```{r, warning=FALSE} 
source("visualizeConnectivityTables.R")
require(igraph)

connectionMeasures = c("weightRelative","weightROIRelativeTotal")
connectionMeasure = connectionMeasures[1]
cutoff = 0.05 # for weight 0.05, 0.01, 0

largeGraph = TRUE
selfFeedbackScale = 10
edcurve = 0.1#0.15
edgeNorm = 0.07#0.05#0.07#0.03#

showself = TRUE 

# drop na in "to" column
myConnectionsT2T = myConnectionsT2T %>% drop_na(type.to)
graphData = data.frame(from = myConnectionsT2T$type.from, to = myConnectionsT2T$type.to, relWeight = myConnectionsT2T$weightRelative)

graphData_noSelf = getNoSelfGraphData(graphData)  
graphData_self = getSelfFBGraphData(graphData)

if (showself){
  graphData = graphData
  graphName = saveName
} else {
  graphData = left_join(graphData_noSelf, graphData_self)
  graphName = paste0(saveName, "_noSelf")
}

# Graph parameter
if(largeGraph){
  vertexSize = 7#+ 7 * graphData$relWeightSelf * selfFeedbackScale
  plotSize = 15
}else{
  vertexSize = 12 #+ 12 * graphData$relWeightSelf * selfFeedbackScale
  plotSize = 10
}

selfFBscale = vertexSize
arrowSize= 0

myGraph = constructConnectivityGraph(graphData, cutoff, vertexSize, selfFBscale, arrowSize, edgeNorm)


# remove isolated nodes
#Isolated = which(degree(myGraph) == 0)
#myGraph = delete.vertices(myGraph, Isolated)

l = layout_with_fr(myGraph)#layout_with_dh(myGraph)#
#l = layout_as_bipartite(myGraph, types = grepl(postpattern,V(myGraph)$name))
myGraph$main = paste0("Connectivity within the ",slctROI)
plot(myGraph,edge.curved=edcurve, layout=l, edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc.pdf"), width=plotSize, height=plotSize)
```

Graph with defined colormap from file
```{r, warning=FALSE} 
cmapNames = c("RingNeurons", "TuBus", "columnar",  "ExR_and_PDM21a")

myColorMap <- read.csv(paste0("~/Documents/code/neuprintR-notebooks/colorMap_",cmapNames[1],".csv"))
if(length(cmapNames) > 1){
  for(cmapName in cmapNames[2:length(cmapNames)]){ 
    tmp = read.csv(paste0("~/Documents/code/neuprintR-notebooks/colorMap_",cmapName,".csv"))
    myColorMap <- full_join(myColorMap[c("Type", "Simpletype", "hex")], tmp[c("Type", "Simpletype","hex")])
    }
}

if(splitLR){
  myColorMap_R = myColorMap %>% mutate(Type = paste0(Type, "_R"))
  myColorMap_L = myColorMap %>% mutate(Type = paste0(Type, "_L"))
  myColorMap= bind_rows(myColorMap_L, myColorMap_R)
}

myColorMap = myColorMap %>% filter(Simpletype == "no")
# drop na in "to" column
myConnectionsT2T = myConnectionsT2T %>% drop_na(type.to)
graphData = data.frame(from = myConnectionsT2T$type.from, to = myConnectionsT2T$type.to, relWeight = myConnectionsT2T$weightRelative)

graphData_noSelf = getNoSelfGraphData(graphData)  
graphData_self = getSelfFBGraphData(graphData)

if (showself){
  graphData = graphData
  graphName = saveName
} else {
  graphData = left_join(graphData_noSelf, graphData_self)
  graphName = paste(saveName, "_noSelf")
}

myGraph = constructConnectivityGraph(graphData, cutoff, vertexSize, selfFBscale, arrowSize, edgeNorm, colormap = myColorMap, useRandCol = FALSE)

myGraph$main = paste0("Connectivity within   the ",slctROI)
plot(myGraph,edge.curved=edcurve, layout=l, edge.color = customizeGraphEdges(myGraph))

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc_custCol.pdf"), width=plotSize, height=plotSize)
```

***Hierarchy graph with node size indicating input/output ratio and sorted by EPG weight***

```{r}
EPGs = neuprint_search("EPG", field = "type")
myConnections_toEPG = getConnectionTable(preIDs$bodyid, "POST", slctROI)
myConnections_toEPG = myConnections_toEPG %>% filter(to %in% EPGs$bodyid) 

typesTable_toEPG <- getTypesTable(unique(myConnections_toEPG$databaseType.to))

if (splitLR){
  # Subdevide types and build a custom types table
  myConnections_toEPG = lateralize_types(myConnections_toEPG, postfix="to")
  myConnections_toEPG = lateralize_types(myConnections_toEPG, postfix="from")
  typesTable_toEPG = lateralize_types(typesTable_toEPG, postfix="raw")
}
myConnectionsT2T_toEPG = getTypeToTypeTable(myConnections_toEPG,typesTable = typesTable_toEPG)

```

Use community info, hierarchy measure and EPG input to generate a layout
```{r}
# find communities
wc = cluster_walktrap(myGraph)
print(modularity(wc))
communitymembership = stack(membership(wc))

# compute hierarchy measure for each node: # of nodes that can be reached
downstreamNodes = data.frame(vertex = V(myGraph)$name, 
                             closeness = closeness(myGraph, vids = V(myGraph), mode = "out", weights = NULL, normalized = TRUE),
                             ndownstream = 1)

for (v in V(myGraph)$name){
  subgraph = delete_vertices(myGraph,v)
  pathfromSouce = all_simple_paths(myGraph, V(myGraph)[v], to = V(myGraph)[c(V(subgraph)$name)], mode = "out")
  nv = length(V(myGraph)[unique(c(unlist(pathfromSouce)))])
  downstreamNodes <- within(downstreamNodes, ndownstream[vertex == v] <- nv)
}

for (v in V(myGraph)$name){
  
  subgraph = delete_vertices(myGraph,v)
}

# align community and EPG input data
layoutInfo = full_join(data.frame("type.from" = V(myGraph)$name), 
                  myConnectionsT2T_toEPG[c("type.from", "weightRelative")])
layoutInfo[is.na(layoutInfo)] <- 0
layoutInfo = layoutInfo %>% mutate(order = rank(weightRelative))
layoutInfo = full_join(layoutInfo, communitymembership, by=c("type.from" = "ind"))
```



```{r, warning=FALSE} 

inWeight = myConnectionsT2T %>% group_by(type.to) %>% summarise(inWeight = sum(weightRelative))
outWeight = myConnectionsT2T %>% group_by(type.from) %>% summarise(outWeight = sum(weightRelative))
weightRatio  = full_join(inWeight,outWeight,by = c("type.to" = "type.from")) %>% mutate(ratio = outWeight/inWeight) %>% rename("type" = "type.to")
weightRatio$ypos <- cut(weightRatio$ratio, breaks = c(seq(0,2.5,0.1), Inf), labels = seq(length(c(seq(0,2.5,0.1), Inf))-1))

vertexBaseSize = 4
myGraph = constructConnectivityGraph(graphData, cutoff, vertexBaseSize, selfFBscale, arrowSize, edgeNorm, colormap = myColorMap)

vertexSize = integer(length(V(myGraph)$name)) + vertexBaseSize
```


Plot
```{r}  
#V1
V(myGraph)$size = vertexSize 
myLayout = matrix(c(layoutInfo$values*5 + 0.5*layoutInfo$order, #as.numeric(l[,1]),
                    as.numeric(weightRatio$ratio)),
  ncol = 2, nrow = length(V(myGraph)$name))

myGraph$main = "Hierarchy between RNs (x ~ community + input to EPGs (low to high), y ~ hierarchy measure)"
plot(myGraph,edge.curved=0.15, layout=norm_coords(myLayout, xmin=-1.5, xmax=1.5, ymin=-1, ymax=1), 
     edge.color = customizeGraphEdges(myGraph), rescale=FALSE)

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc_inOutRatio.pdf"), width=20, height=10)


# V2: 
for (i in seq(1, length(V(myGraph)$name))) {
  ratio = weightRatio %>% filter(type == V(myGraph)$name[i]) %>% select(ratio)
  vertexSize[i] = ratio$ratio * vertexBaseSize + vertexBaseSize
}

V(myGraph)$size = vertexSize 
myLayout = matrix(c(jitter(layoutInfo$values*1),
                    layoutInfo$order),
  ncol = 2, nrow = length(V(myGraph)$name))

myGraph$main = "Hierarchy between RNs \n(x ~ community + jitter, y ~ input to EPGs (low to high),  vertex size ~ hierarchy measure)"
plot(myGraph,edge.curved=0.15, layout=norm_coords(myLayout, xmin=-1.75, xmax=1.75, ymin=-1, ymax=1), 
     edge.color = customizeGraphEdges(myGraph), rescale=FALSE,  cex.lab=1.5, cex.axis=1)

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc_byEPG.pdf"), width=30, height=15)
```



Plot
```{r}  
#V1
V(myGraph)$size = vertexSize 
myLayout = matrix(c(layoutInfo$values*5 + 0.5*layoutInfo$order, #as.numeric(l[,1]),
                    as.numeric(downstreamNodes$closeness)),
  ncol = 2, nrow = length(V(myGraph)$name))

myGraph$main = "Hierarchy between RNs (x ~ community + input to EPGs (low to high), y ~ hierarchy measure)"
plot(myGraph,edge.curved=0.15, layout=norm_coords(myLayout, xmin=-1.5, xmax=1.5, ymin=-1, ymax=1), 
     edge.color = customizeGraphEdges(myGraph), rescale=FALSE)

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc_hierarchy.pdf"), width=20, height=12)

```


## Use ROI innervation of types to structure graph
```{r}
myTypes = unique(c(preIDs$databaseType, postIDs$databaseType))
myIDs = unique(c(preIDs$bodyid, postIDs$bodyid))
myTypes

roiInfo = getRoiInfo(myIDs) %>% 
  filter(roi %in% c("NO1(R)", "NO2(R)", "NO3(R)")) %>% 
  filter(upstream >= 10 | downstream >= 10) %>%
  mutate(type = neuprint_get_meta(bodyid)$type, 
         name = neuprint_get_meta(bodyid)$name,
         databaseType = neuprint_get_meta(bodyid)$type, 
         databaseName = neuprint_get_meta(bodyid)$name,) %>%
  group_by(type) %>% mutate(roi_per_type = paste0(unique(roi), collapse = "_"))

roiInfo = lateralize_types(roiInfo, postfix="raw")

roiInfo = unique(roiInfo[c("type","roi_per_type")])

vertexProps = unique(left_join(data.frame(type = V(myGraph)$name), roiInfo)[c("type","roi_per_type")]) %>%
  mutate(xloc = 1, yloc = 1) %>% 
  mutate(simpletype = sub("_L", "", type)) %>% mutate(simpletype = sub("_R", "", simpletype))

 
```
position based on compartment
```{r}
compartments = sort(unique(vertexProps$roi_per_type))

inlayer = c("GLNO","LNO1", "LNO2", "LNO3", "LNOa","LCNOpm", "LCNOp")
midlayer = myTypes[grep("PFN.*", myTypes)]
outlayer = myTypes[grep("FB*", myTypes)]

for(i in seq(length(compartments))){
  comp = compartments[i]
  print(comp)
  vertexProps[vertexProps$roi_per_type == comp,] = vertexProps[vertexProps$roi_per_type == comp,] %>% 
    mutate(xloc =i*3, yloc = seq(sum(vertexProps$roi_per_type == comp)) )
}

vertexProps[vertexProps$simpletype %in% inlayer,] = vertexProps[vertexProps$simpletype %in% inlayer,] %>% 
    mutate(xloc = xloc -0.25)
vertexProps[vertexProps$simpletype %in% midlayer,] = vertexProps[vertexProps$simpletype %in% midlayer,] %>% 
    mutate(xloc = xloc +0.4)
vertexProps[vertexProps$simpletype %in% outlayer,] = vertexProps[vertexProps$simpletype %in% outlayer,] %>% 
    mutate(xloc = xloc +0.5)

plot(myGraph,edge.curved=0.15, layout=norm_coords(as.matrix(vertexProps[,c("xloc","yloc")]), 
                                                 xmin=-1.75, xmax=1.75, ymin=-1, ymax=1),  rescale=FALSE,
     edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_",connectionMeasure, cutoff,"_byCompartment.pdf"), width=30, height=15)
```
color based on compartment

```{r}
library("paletteer")

pal = paletteer_c("grDevices::Dark 3",n=length(compartments))

for(i in seq(length(V(myGraph)))){
  myGraph = set.vertex.attribute(myGraph, 'comp', i, 
                                vertexProps[which(vertexProps$type==V(myGraph)$name[i]),]$roi_per_type)
}

plot(myGraph,edge.curved=0.15, layout=l,
     vertex.color = pal[as.numeric(as.factor(vertex_attr(myGraph, "comp")))]) # use 0.5 curved if edges overlap
legend("topleft", legend = levels(as.factor(vertex_attr(myGraph, "comp"))), pch = 16, col = pal, bty = "n")


dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_",connectionMeasure, cutoff,"_byCompartmentCol.pdf"), width=20, height=15)
```

## Use knowledge about ROI innervation to position the vertices
```{r}
load(paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NO/NO_Types.RData"))

vertexProps = data.frame(name = V(myGraph)$name, col = V(myGraph)$color) %>% mutate(name = gsub("_[R,L]", "", name))
vertexProps = vertexProps %>% mutate(loc = "NO") 
vertexProps = vertexProps %>% mutate(xloc = 1*seq(sum(vertexProps$loc == "NO")), yloc = -3) 
vertexProps[vertexProps$name %in% NO1_Type,] = vertexProps[vertexProps$name %in% NO1_Type,] %>% 
    mutate(loc = paste0(loc, "1"), xloc = -2)
vertexProps[vertexProps$name %in% NO2_Type,] = vertexProps[vertexProps$name %in% NO2_Type,] %>% 
    mutate(loc = paste0(loc, "2"), xloc = 0)
vertexProps[vertexProps$name %in% NO3_Type,] = vertexProps[vertexProps$name %in% NO3_Type,] %>% 
    mutate(loc = paste0(loc, "3"), xloc = 2)

if ("NO1" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO1",] = vertexProps[vertexProps$loc == "NO1",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO1")))
}
if ("NO2" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO2",] = vertexProps[vertexProps$loc == "NO2",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO2")))
}
if ("NO3" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO3",] = vertexProps[vertexProps$loc == "NO3",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO3")))
}
if ("NO12" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO12",] = vertexProps[vertexProps$loc == "NO12",] %>% 
    mutate(xloc = -1, yloc = -1.5 +seq(sum(vertexProps$loc == "NO12")))
}
if ("NO13" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO13",] = vertexProps[vertexProps$loc == "NO13",] %>% 
    mutate(xloc = -0.25, yloc = -1.5 + seq(sum(vertexProps$loc == "NO13")))
}
if ("NO23" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO23",] = vertexProps[vertexProps$loc == "NO23",] %>% 
    mutate(xloc = 1, yloc = -1.5 +seq(sum(vertexProps$loc == "NO23")))
}
if ("NO123" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO123",] = vertexProps[vertexProps$loc == "NO123",] %>% 
    mutate(xloc = 0.25, yloc = -1.5 +seq(sum(vertexProps$loc == "NO123")))
}
plot(myGraph,edge.curved=0.5, layout=layout.norm(as.matrix(vertexProps[,c("xloc","yloc")])), 
     edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_",connectionMeasure, cutoff,"_byCompartment.pdf"), width=plotSize, height=plotSize)
```

## Separate input and output
```{r}
prepattern = "MC"
midpattern = "TuTu"
postpattern = "TuBu"
vertexProps = data.frame(name = V(myGraph)$name, col = V(myGraph)$color) %>% mutate(name = gsub("_[R,L]", "", name))
vertexProps = vertexProps %>% mutate(loc = "pre") 
vertexProps = vertexProps %>% mutate(xloc = seq(sum(vertexProps$loc == "pre")), yloc = 2) 
vertexProps[vertexProps$name %in% unique(postIDs$type)[grepl(postpattern,unique(postIDs$type))],] = vertexProps[vertexProps$name %in% unique(postIDs$type)[grepl(postpattern,unique(postIDs$type))],] %>% 
    mutate(loc = "post", yloc = 0, xloc = 2*seq(length(loc)))
vertexProps[vertexProps$name %in% unique(preIDs$type)[grepl(midpattern,unique(preIDs$type))],] = vertexProps[vertexProps$name %in% unique(preIDs$type)[grepl(midpattern,unique(preIDs$type))],] %>% 
    mutate(loc = "mid", yloc = 1, xloc = 2.5*seq(length(loc)))
vertexProps[vertexProps$name %in% unique(preIDs$type)[grepl(prepattern,unique(preIDs$type))],] = vertexProps[vertexProps$name %in% unique(preIDs$type)[grepl(prepattern,unique(preIDs$type))],] %>% 
    mutate(loc = "prepre", yloc = 3, xloc = 5*seq(length(loc)))
curve = 0 #0.15


#if ("post" %in% vertexProps$loc){
#  vertexProps[vertexProps$loc == "post",] = vertexProps[vertexProps$loc == "post",] %>% mutate(yloc = #seq(sum(vertexProps$loc == "post")))
#}
plot(myGraph,edge.curved=curve, layout=layout.norm(as.matrix(vertexProps[,c("xloc","yloc")])), 
     edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_",connectionMeasure, cutoff,"_pre-post.pdf"), width=plotSize, height=plotSize)
```