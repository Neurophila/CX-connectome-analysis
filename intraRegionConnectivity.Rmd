---
title: "Tools for analysing connectivity between neurons within a region"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(dplyr)
options(nat.plotengine = 'rgl')

neuprint_login()
```

```{r, messages=FALSE, warning=FALSE}
# Get some custom functions
source("neuprintQueryUtils.R")
source("visualizeConnectivityTables.R")

# To be able to use ? for accessing doc strings in custom functions, please install the "docstring" package. Alternatively use docstring(function)
#library(docstring)
```


### Make selection of neurons to be used in connecitivy analysis
This should be done based on some broadly used criteria. Alternatively, one could read in previously curated lists of neurons.
```{r}
ROI = "NO"
slctROI = "NO(R)"#"LAL(-GA)(R)"

splitLR = TRUE

saveName = paste0("columnar_in_",slctROI) #paste0("allBU")
if(splitLR){saveName = paste0(saveName,"_LR")}

useCuratedListPost = FALSE#
useCuratedListPre = FALSE#

#only relevant if one of the above is false:
useCustomPostSelection = TRUE
useCustomPreSelection = TRUE

```


***Selection of post neurons***
```{r}
if (useCuratedListPost) {
  # load list
  load(paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/",ROI,"/",ROI,"_Types.RData"))
  
  # select neurons from there
  postNeuron = get(paste0(ROI,"_Type"))
  postNeuron <- gsub("\\(.*\\)", "", postNeuron)
  postName = paste0(ROI, " neurons")
  
  postIDs = getBodyIdsForList(postNeuron, field="type")
  
} else{
  if(useCustomPostSelection){
    postNeuron = c("PFN", "PEN")
    #c("R1.*","R2.*","R3.*","R4.*","R5.*","R6.*")#c("EL","EPG","EPGt","PEG","PEN_a","PEN_b")#
    #, "ExR","EPG","EL","EPGt","PEG","PEN","PEN") #c("PDM21a.*","TuBu.*", "TuTuB.*")# 
    # c("R1.*","R2.*","R3.*","R4.*","R5.*","R6.*", "ExR.*")
      #c("PDM21a.*","TuBu.*")#
    postName = paste0("columnar in ",slctROI)
  }else{
    postName = paste0("", ROI)

    synCutoff = 10
    relWeightCutoff = .01 # percent input or output in that region
    relWeightROICutoff = .005 # percent total input
    
    
    # get all connections
    roiNeurons = neuprint_bodies_in_ROI(slctROI) %>% 
      mutate(name=neuprint_get_meta(as.numeric(bodyid), all_segments = TRUE)[["name"]],
             type=neuprint_get_meta(as.numeric(bodyid), all_segments = TRUE)[["type"]])
    #partnersInRoi = getConnectionTable(preIDs$bodyid, "POST", slctROI)
    
    # find relevant partners
    postNeuron = roiNeurons %>% group_by(type) %>% filter((roipre > synCutoff) | (roipost > synCutoff))
    #postNeuron = unique( c(unique(partnersInRoi$type.from) , unique(partnersInRoi$type)) )
    
    #parnerPlot = ggplot(partnersInRoi %>% filter(type.from %in% preNeuron), aes(x=type.from, fill=type.from)) 
    parnerPlot = ggplot(postNeuron, aes(x=type, fill=type)) 
    
    parnerPlot = parnerPlot + geom_bar() + theme_classic() + theme(axis.text.x = element_text(angle = 90)) + guides(fill=FALSE)
    print(parnerPlot)
    
    postNeuron = unique(postNeuron$type)
  }
  
  postIDs = getBodyIdsForList(postNeuron)
}
```

***Selection of pre neurons***

```{r}
if (useCuratedListPre) {
  # load list
  load(paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/",ROI,"/",ROI,"_Types.RData"))
  
  # select neurons from there
  preNeuron = get(paste0(ROI,"_Type"))
  preNeuron <- gsub("\\(.*\\)", "", preNeuron)
  preIDs = getBodyIdsForList(preNeuron, field="type")
  preName = paste0(ROI, "neurons")

} else{
  if(useCustomPreSelection){
    preNeuron = c("PFN", "PEN")
    preName = paste0("columnar in ",slctROI)
  }else{
    preName = paste0("Inputs in ", ROI)

    synCutoff = 3
    relWeightCutoff = .01 # percent input or output in that region
    relWeightROICutoff = .005 # percent total input
    
    # get all connections
    seedIDs = postIDs%>% filter(statusLabel == "Traced")
    partnersInRoi = getConnectionTable(seedIDs$bodyid , "PRE", slctROI)
    
    # find relevant partners
    preNeuron = unique( c(unique(partnersInRoi$type.from) , unique(partnersInRoi$type)) )
  
    parnerPlot = ggplot(partnersInRoi %>% filter(type.from %in% preNeuron), aes(x=type.from, fill=type.from)) + geom_bar() + theme_classic() + 
    theme(axis.text.x = element_text(angle = 90)) + guides(fill=FALSE)
    print(parnerPlot)
  }
  preIDs = getBodyIdsForList(preNeuron)
}
```

### Get connectivity table
```{r, warning=FALSE}
myConnections = getConnectionTable_forSubset(preIDs$bodyid,postIDs$bodyid, slctROI)
#write.csv(myConnections, paste0("../neuprintR_analysis_plots/connectivityTable_",saveName,'_byid.csv'), row.names = FALSE)
#library(igraph)
#edge_list <- myConnections[c("from","type.to","weightRelative")]
#G <- graph.data.frame(edge_list,directed=TRUE);
#A <- as_adjacency_matrix(G,type="both",names=TRUE,sparse=FALSE,attr="weightRelative");
```

```{r}
myConnections_simple = simplifyConnectionTable(myConnections)

typesTable <- getTypesTable(unique(myConnections_simple$databaseType.to))

if (splitLR){
  # Subdevide types and build a custom types table
  myConnections_simple = lrSplit(myConnections_simple, nameCol="name.to",typeCol="type.to")
  myConnections_simple = lrSplit(myConnections_simple, nameCol="name.from",typeCol="type.from")
  typesTable = lrSplit(typesTable, nameCol="name",typeCol="type")
}
```

```{r}
myConnectionsT2T = getTypeToTypeTable(myConnections_simple,typesTable = typesTable)

ggplot(data= myConnectionsT2T, aes(x = n_targets, y = varWeight, color=type.from)) + 
  #geom_label(aes(label=as.character(type.to)), position = "nudge") + 
  geom_point()
ggplot(data= myConnectionsT2T, aes(x = n_targets, y = varWeight, color=type.to)) + 
  #geom_label(aes(label=as.character(type.to)), position = "nudge") + 
  geom_point()

```


### Connectivity matrix
```{r}
plotW = 20 # 20
plotH = 17  #17
cmax = NULL
connectionMeasures = c("weightRelative")#,"weight")

for (connectionMeasure in connectionMeasures){
  
  conMatPlot = plotConnectivityMatrix(myConnectionsT2T, byGroup = "type", connectionMeasure, cmax)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  #conMatPlot = structureMatrixPlotByType(conMatPlot)
  print(conMatPlot)
  ggsave( paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'_byType.pdf', sep=''), plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
    scale = 1.5, width = plotW*0.8, height = plotH*0.8, units ="cm", dpi = 600, limitsize = TRUE)
  
  conMatPlot = plotConnectivityMatrix(myConnections_simple, byGroup = "name", connectionMeasure,cmax)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  conMatPlot = structureMatrixPlotByType(conMatPlot)
  print(conMatPlot)
  ggsave( paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'_byName.pdf', sep=''), 
    plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
    scale = 1.5, width = plotW*0.8, height = plotH*0.8, units ="cm", dpi = 600, limitsize = TRUE)
  
  conMatPlot = plotConnectivityMatrix(myConnections_simple, byGroup = "id", connectionMeasure, cmax)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  conMatPlot = structureMatrixPlotByType(conMatPlot)
  print(conMatPlot)
  ggsave(paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'_byID.pdf', sep=''), 
    plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
    scale = 2, width = plotW, height =plotH, units ="cm", dpi = 600, limitsize = TRUE)
}
```

###  Draw graph

```{r, warning=FALSE} 
source("visualizeConnectivityTables.R")
require(igraph)

connectionMeasures = c("weightRelative","weightROIRelativeTotal")
connectionMeasure = connectionMeasures[1]
cutoff = 0.01 # for weight 0.05, 0.01, 0

showself = FALSE

# drop na in "to" column
myConnectionsT2T = myConnectionsT2T %>% drop_na(type.to)
graphData = data.frame(from = myConnectionsT2T$type.from, to = myConnectionsT2T$type.to, relWeight = myConnectionsT2T$weightRelative)

graphData_noSelf = getNoSelfGraphData(graphData)  
graphData_self = getSelfFBGraphData(graphData)

if (showself){
  graphData = graphData
  graphName = saveName
} else {
  graphData = left_join(graphData_noSelf, graphData_self)
  graphName = paste(saveName, "_noSelf")
}

# Graph parameter
largeGraph = FALSE
selfFeedbackScale = 10
edcurve = 0.2# 0.5
if(largeGraph){
  vertexSize = 7#+ 7 * graphData$relWeightSelf * selfFeedbackScale
  plotSize = 15
}else{
  vertexSize = 12 #+ 12 * graphData$relWeightSelf * selfFeedbackScale
  
  plotSize = 10
}

selfFBscale = vertexSize
arrowSize= 0

edgeNorm = 0.05#0.07#0.03#

myGraph = constructConnectivityGraph(graphData, cutoff, vertexSize, selfFBscale, arrowSize, edgeNorm)


# remove isolated nodes
Isolated = which(degree(myGraph) == 0)
myGraph = delete.vertices(myGraph, Isolated)

l = layout_with_fr(myGraph)#layout_with_dh(myGraph)#

myGraph$main = paste0("Connectivity within the ",slctROI)
plot(myGraph,edge.curved=edcurve, layout=l, edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc.pdf"), width=plotSize, height=plotSize)
```

Graph with defined colormap from file
```{r, warning=FALSE} 
cmapNames = c("RingNeurons", "columnar",  "ExR_and_PDM21a")

myColorMap <- read.csv(paste0("~/Documents/code/neuprintR-notebooks/colorMap_",cmapNames[1],".csv"))
if(length(cmapNames) > 1){
  for(cmapName in cmapNames[2:length(cmapNames)]){
    myColorMap <- full_join(myColorMap,read.csv(paste0("~/Documents/code/neuprintR-notebooks/colorMap_",cmapName,".csv")))
    }
}
source("visualizeConnectivityTables.R")

connectionMeasure = "weightRelative"
cutoff = 0.05 # for weight 0.05, 0.01, 0

showself = FALSE

# drop na in "to" column
myConnectionsT2T = myConnectionsT2T %>% drop_na(type.to)
graphData = data.frame(from = myConnectionsT2T$type.from, to = myConnectionsT2T$type.to, relWeight = myConnectionsT2T$weightRelative)

graphData_noSelf = getNoSelfGraphData(graphData)  
graphData_self = getSelfFBGraphData(graphData)

if (showself){
  graphData = graphData
  graphName = saveName
} else {
  graphData = left_join(graphData_noSelf, graphData_self)
  graphName = paste(saveName, "_noSelf")
}

# Graph parameter
largeGraph = FALSE
selfFeedbackScale = 10
edcurve = 0.2# 0.5
if(largeGraph){
  vertexSize = 7#+ 7 * graphData$relWeightSelf * selfFeedbackScale
  plotSize = 15
}else{
  vertexSize = 9
  plotSize = 12
}
edgeNorm = 0.05#0.07#0.03#

myGraph = constructConnectivityGraph(graphData, cutoff, vertexSize, selfFBscale, arrowSize, edgeNorm, colormap = myColorMap)

# remove isolated nodes
Isolated = which(degree(myGraph) == 0)
myGraph = delete.vertices(myGraph, Isolated)

l = layout_with_fr(myGraph)#layout_with_dh(myGraph)#

myGraph$main = paste0("Connectivity within the ",slctROI)
plot(myGraph,edge.curved=edcurve, layout=l, edge.color = customizeGraphEdges(myGraph))

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc_custCol.pdf"), width=plotSize, height=plotSize)
```
Graph with node size indicating input/output ratio
```{r, warning=FALSE} 

inWeight = myConnectionsT2T %>% group_by(type.to) %>% summarise(inWeight = sum(weightRelative))
outWeight = myConnectionsT2T %>% group_by(type.from) %>% summarise(outWeight = sum(weightRelative))
weightRatio  = full_join(inWeight,outWeight,by = c("type.to" = "type.from")) %>% mutate(ratio = outWeight/inWeight) %>% rename("type" = "type.to")

weightRatio$ypos <- cut(weightRatio$ratio, breaks = c(seq(0,2.5,0.1), Inf), labels = seq(length(c(seq(0,2.5,0.1), Inf))-1))

cutoff = 0.05

vertexBaseSize = 7
myGraph = constructConnectivityGraph(graphData, cutoff, vertexBaseSize, selfFBscale, arrowSize, edgeNorm, colormap = myColorMap)

vertexSize = integer(length(V(myGraph)$name)) + 1

for (i in seq(1, length(V(myGraph)$name))) {
  ratio = weightRatio %>% filter(type == V(myGraph)$name[i]) %>% select(ratio)
  vertexSize[i] = ratio$ratio * vertexBaseSize + 3
}

V(myGraph)$size = vertexSize
#l = layout_with_dh(myGraph)#
myLayout = matrix(c(as.numeric(l[,1]+0.5*l[,2]),
                    as.numeric(weightRatio$ypos)),
  ncol = 2, nrow = length(V(myGraph)$name))
                       
myGraph$main = paste0("Connectivity within the ",slctROI)
plot(myGraph,edge.curved=0.2, layout=layout.norm(myLayout), edge.color = customizeGraphEdges(myGraph))

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",graphName,'_in_',slctROI,
                      "_",connectionMeasure, round(100*cutoff),"perc_inOutRatio.pdf"), width=15, height=15)
```


### Use knowledge about ROI innervation to position the vertices
***NO***
```{r}
load(paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/NO/NO_Types.RData"))

vertexProps = data.frame(name = V(myGraph)$name, col = V(myGraph)$color) %>% mutate(name = gsub("_[R,L]", "", name))
vertexProps = vertexProps %>% mutate(loc = "NO") 
vertexProps = vertexProps %>% mutate(xloc = 1*seq(sum(vertexProps$loc == "NO")), yloc = -3) 
vertexProps[vertexProps$name %in% NO1_Type,] = vertexProps[vertexProps$name %in% NO1_Type,] %>% 
    mutate(loc = paste0(loc, "1"), xloc = -2)
vertexProps[vertexProps$name %in% NO2_Type,] = vertexProps[vertexProps$name %in% NO2_Type,] %>% 
    mutate(loc = paste0(loc, "2"), xloc = 0)
vertexProps[vertexProps$name %in% NO3_Type,] = vertexProps[vertexProps$name %in% NO3_Type,] %>% 
    mutate(loc = paste0(loc, "3"), xloc = 2)

if ("NO1" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO1",] = vertexProps[vertexProps$loc == "NO1",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO1")))
}
if ("NO2" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO2",] = vertexProps[vertexProps$loc == "NO2",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO2")))
}
if ("NO3" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO3",] = vertexProps[vertexProps$loc == "NO3",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO3")))
}
if ("NO12" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO12",] = vertexProps[vertexProps$loc == "NO12",] %>% 
    mutate(xloc = -1, yloc = -1.5 +seq(sum(vertexProps$loc == "NO12")))
}
if ("NO13" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO13",] = vertexProps[vertexProps$loc == "NO13",] %>% 
    mutate(xloc = -0.25, yloc = -1.5 + seq(sum(vertexProps$loc == "NO13")))
}
if ("NO23" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO23",] = vertexProps[vertexProps$loc == "NO23",] %>% 
    mutate(xloc = 1, yloc = -1.5 +seq(sum(vertexProps$loc == "NO23")))
}
if ("NO123" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO123",] = vertexProps[vertexProps$loc == "NO123",] %>% 
    mutate(xloc = 0.25, yloc = -1.5 +seq(sum(vertexProps$loc == "NO123")))
}
plot(myGraph,edge.curved=0.5, layout=layout.norm(as.matrix(vertexProps[,c("xloc","yloc")])), 
     edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_",connectionMeasure, cutoff,"_byCompartment.pdf"), width=plotSize, height=plotSize)
```

