---
title: "Illustration of tools for analysing connectivity between neurons within a region"
output:
  html_document:
    df_print: paged
---

```{r message=FALSE, warning=FALSE}
library(nat)
library(neuprintr)
library(tidyverse)
library(dplyr)
options(nat.plotengine = 'rgl')

neuprint_login()
```

```{r, messages=FALSE, warning=FALSE}
# Get some custom functions
source("neuprintQueryUtils.R")
source("visualizeConnectivityTables.R")

# To be able to use ? for accessing doc strings in custom functions, please install the "docstring" package. Alternatively use docstring(function)
library(docstring)
```


### Make selection of neurons to be used in connecitivy analysis
This should be done based on some broadly used criteria. Alternatively, one could read in previously curated lists of neurons.
***Selection of post neurons***
```{r}
useCuratedList = TRUE

ROI = "NO"#
slctROI = "NO(L)"#

if (useCuratedList) {
  # load list
  load(paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/",ROI,"/",ROI,"_Types.RData"))
  
  # select neurons from there
  postNeuron = get(paste0(ROI,"_Type"))
  postNeuron <- gsub("\\(.*\\)", "", postNeuron)
  postName = paste0(ROI, " neurons")
  postIDs = getBodyIdsForList(postNeuron, field="type")
  
} else{
  postNeuron = c("LN1", "LN2", "LN3", "LNa")#, "LCNp", "LCNpm")  #"PFN"#
  postName = "PFN3avd-inputs"#"PFNs"#
  postIDs = getBodyIdsForList(postNeuron)
}
```

***Selection of pre neurons***
```{r}
useCuratedList = FALSE

if (useCuratedList) {
  # load list
  load(paste0("/Users/haberkernh/Dropbox (HHMI)/FIBSEM CX Paper Jan 2020/Figures/",ROI,"/",ROI,"_Types.RData"))
  
  # select neurons from there
  preNeuron = get(paste0(ROI,"_Type"))
  preNeuron <- gsub("\\(.*\\)", "", preNeuron)
  preIDs = getBodyIdsForList(preNeuron, field="type")
  preName = paste0(ROI, "neurons")
  saveName = paste0(ROI,"neurons")
  
} else{
  preName = paste0(ROI,"Neuron Partners")
  saveName = paste0(ROI,"Inputs")

  synCutoff = 3
  relWeightCutoff = .01 # percent input or output in that region
  relWeightROICutoff = .005 # percent total input
  
  # get all connections
  myConnections = getConnectionTable(postIDs$bodyid, "PRE", slctROI)
  
  # find relevant partners
  partnersInRoi =  myConnections #%>% 

  preNeuron = unique( c(unique(partnersInRoi$partnerType) , unique(partnersInRoi$type)) )

  parnerPlot = ggplot(myConnections %>% filter(partnerType %in% preNeuron), aes(x=partnerType, fill=partnerType)) + geom_bar() + theme_classic() + 
  theme(axis.text.x = element_text(angle = 90)) + guides(fill=FALSE)
  
  preIDs = getBodyIdsForList(preNeuron)
  
  print(parnerPlot)
}
```

### Get connectivity table
```{r, warning=FALSE}
myConnections = getConnectionTable_forSubset(preIDs$bodyid,postIDs$bodyid, slctROI)
```

```{r}
majorOutputThreshold=0.8
singleNeuronThreshold= 0.01
pThresh = 0.05

synCutoff = 3

myConnections_simple = simplifyConnectionTable(myConnections)

#Filter out based on minumum abs. number of synapses
myConnections_simple = myConnections_simple %>% filter(ROIweight > synCutoff)

myConnectionsT2T = getTypeToTypeTable(myConnections_simple, majorOutputThreshold,singleNeuronThreshold, pThresh)
```

```{r}
ggplot(data= myConnectionsT2T, aes(x = n_links, y = varWeight, color=type.to)) + 
  #geom_label(aes(label=as.character(type.to)), position = "nudge") + 
  geom_point()

```

### Connectivity matrix
```{r}

connectionMeasures = c("weightRelative","weightROIRelativeTotal")

for (connectionMeasure in connectionMeasures){
  conMatPlot = plotConnectivityMatrix(myConnections %>% filter(ROIweight > synCutoff), byType = TRUE, connectionMeasure)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  print(conMatPlot)
  ggsave( paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'.pdf', sep=''), plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
    scale = 1.5, width = 20, height = 15, units ="cm", dpi = 600, limitsize = TRUE)
  
  conMatPlot = plotConnectivityMatrix(myConnections %>% filter(ROIweight > synCutoff), byType = FALSE, connectionMeasure)
  conMatPlot = addMatrixPlotLabs(conMatPlot, preName,  postName, slctROI, connectionMeasure)
  conMatPlot = structureMatrixPlotByType(conMatPlot)
  print(conMatPlot)
  ggsave(paste("connectivityMatrix_",saveName,'_in_',slctROI,'_',connectionMeasure,'_byID.pdf', sep=''), plot = conMatPlot, device='pdf', path = "../neuprintR_analysis_plots/",
    scale = 2, width = 20, height =16, units ="cm", dpi = 600, limitsize = TRUE)

}
```

###  Draw graph
```{r, warning=FALSE}
source("visualizeConnectivityTables.R")
require(igraph)

connectionMeasures = c("weightRelative","weightROIRelativeTotal")
connectionMeasure = connectionMeasures[1]
cutoff = 0.05 # for weight 0.05, 0.01, 0

# drop na in "to" column
myConnectionsT2T = myConnectionsT2T %>% drop_na(type.to)
graphData = data.frame(from = myConnectionsT2T$type.from,
                       to = myConnectionsT2T$type.to,
                       relWeight = myConnectionsT2T$weightRelative)

#graphData_noSelf = getNoSelfGraphData(graphData)
#graphData_selfFB = getSelfFBGraphData(graphData)

# Graph parameter
largeGraph = FALSE
selfFeedbackScale = 5
if(largeGraph){
  vertexSize = 8 #+ 8 * graphData$relWeightSelf * selfFeedbackScale
  plotSize = 20
}else{
  vertexSize = 12 #+ 12 * graphData$relWeightSelf * selfFeedbackScale
  plotSize = 15
}
selfFBscale = vertexSize
arrowSize= 0
edgeNorm = 0.07#0.02

myGraph = constructConnectivityGraph(graphData, cutoff, vertexSize, selfFBscale, arrowSize, edgeNorm)

# remove isolated nodes
Isolated = which(degree(myGraph) == 0)
myGraph = delete.vertices(myGraph, Isolated)

l = layout_with_dh(myGraph)

myGraph$main = paste0("Connectivity within the ",slctROI) 
plot(myGraph,edge.curved=0.5, layout=l, edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_",connectionMeasure, cutoff,".pdf"), width=plotSize, height=plotSize)
```

### Use knowledge about ROI innervation to position the vertices
***NO***
```{r}
vertexProps = data.frame(name = V(myGraph)$name, col = V(myGraph)$color)
vertexProps = vertexProps %>% mutate(loc = "NO", xloc = -0.5, yloc = 0) 
vertexProps[vertexProps$name %in% NO1_Type,] = vertexProps[vertexProps$name %in% NO1_Type,] %>% 
    mutate(loc = paste0(loc, "1"), xloc = -2)
vertexProps[vertexProps$name %in% NO2_Type,] = vertexProps[vertexProps$name %in% NO2_Type,] %>% 
    mutate(loc = paste0(loc, "2"), xloc = 0)
vertexProps[vertexProps$name %in% NO3_Type,] = vertexProps[vertexProps$name %in% NO3_Type,] %>% 
    mutate(loc = paste0(loc, "3"), xloc = 2)

vertexProps[vertexProps$loc == "NO1",] = vertexProps[vertexProps$loc == "NO1",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO1")))
vertexProps[vertexProps$loc == "NO2",] = vertexProps[vertexProps$loc == "NO2",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO2")))
vertexProps[vertexProps$loc == "NO3",] = vertexProps[vertexProps$loc == "NO3",] %>% mutate(yloc = seq(sum(vertexProps$loc == "NO3")))

if ("NO12" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO12",] = vertexProps[vertexProps$loc == "NO12",] %>% 
    mutate(xloc = -1, yloc = -1.5 +seq(sum(vertexProps$loc == "NO12")))
}
if ("NO13" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO13",] = vertexProps[vertexProps$loc == "NO13",] %>% 
    mutate(xloc = -0.25, yloc = -1.5 + seq(sum(vertexProps$loc == "NO13")))
}
if ("NO23" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO23",] = vertexProps[vertexProps$loc == "NO23",] %>% 
    mutate(xloc = 1, yloc = -1.5 +seq(sum(vertexProps$loc == "NO23")))
}
if ("NO123" %in% vertexProps$loc){
  vertexProps[vertexProps$loc == "NO123",] = vertexProps[vertexProps$loc == "NO123",] %>% 
    mutate(xloc = 0.25, yloc = -1.5 +seq(sum(vertexProps$loc == "NO123")))
}
plot(myGraph,edge.curved=0.5, layout=layout.norm(as.matrix(vertexProps[,c("xloc","yloc")])), 
     edge.color = customizeGraphEdges(myGraph)) # use 0.5 curved if edges overlap

dev.print(pdf, paste0("../neuprintR_analysis_plots/connectivityGraph_",saveName,'_in_',slctROI,
                      "_",connectionMeasure, cutoff,"_anatomicalPos.pdf"), width=plotSize, height=plotSize)
```



```{r}
library(tidygraph)
library(ggraph)

myGraph_loops = constructConnectivityGraph(nodes, graphData, graphData_selfFB, cutoff, vertexSize, 0, arrowSize, edgeNorm, nodeCols)

nodeCols = customizeGraphEdges(myGraph_loops)
myTidyGraph =  as_tbl_graph(myGraph_loops)
myTidyGraph

ggraph(myTidyGraph) + 
  geom_edge_link(aes(width=relWeight, color=nodeCols), 
                end_cap = circle(1, 'mm'),
                 arrow = arrow(angle=20, 
                             length=unit(0.1,"inches"),
                             type="closed")) + 
  geom_edge_loop(aes(width=relWeight, color=nodeCols)) + 
  geom_node_point(aes(color=color, size = (size-vertexSize))) + 
  geom_node_text(aes(label = name), color = "black", size = 3) + 
  theme_graph()
```


### Illustration of other graph analyses 
```{r}
hs <- hub_score(myGraph, weights=NA)$vector
as <- authority_score(myGraph, weights=NA)$vector

par(mfrow=c(1,2))
plot(myGraph, vertex.size=hs*40, main="Hubs", layout = l)
plot(myGraph, vertex.size=as*40, main="Authorities", layout = l)

```
```{r}
cfg <- cluster_edge_betweenness(as.undirected(myGraph))
#plot(cfg, as.undirected(connectGraph))

V(myGraph)$community <- cfg$membership
colrs <- adjustcolor( c("seagreen", "orange", "tomato",  "gold", "plum","yellowgreen","cyan"), alpha=.6)
plot(myGraph, vertex.color=colrs[V(myGraph)$community])
```

```{r}
deg <- degree(myGraph, mode="all")
deg.dist <- degree_distribution(myGraph, cumulative=T, mode="all")
plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange",
      xlab="Degree", ylab="Cumulative Frequency")
```



### Experimenting with new connectivity table query
```{r}
roiHierarchy = neuprint_ROI_hierarchy()
myConnections2 = getConnectionTable(postIDs$bodyid, "PRE", by.roi = TRUE) %>% 
  mutate(parentRoi = roi %in% roiHierarchy$parent)
```

Filter out connections with that are irrelavant
```{r}
synCutoff = 3
relWeightCutoff = 0.1 # percent input or output in that region
relWeightROICutoff = 0.01 # percent total input

# find relevant partners
myConnections3 <- myConnections2 %>% filter(parentRoi == FALSE)

myConnections3 <-  myConnections3 %>% 
  filter(ROIweight > synCutoff)  %>% # minimum number of synapses in ROI for a given connection
  group_by(type) %>% 
  filter( (weightRelative >= relWeightCutoff) & (weightROIRelativeTotal >=  relWeightROICutoff) )
```

```{r}
countsPerRegion <- myConnections3 %>% group_by(type, roi) %>% 
      summarise(meanTotalROIweight = mean(totalROIweight),
                meanROIweight = mean(ROIweight),
                npartnerTypes = length(unique(partnerType)),
                npartners = length(unique(partner)),
                partnersRatio = length(unique(partner))/length(unique(bodyid)))
head(countsPerRegion)
```
```{r}
ggplot(countsPerRegion, aes(x=roi, y=type, size=meanTotalROIweight, color=meanROIweight)) + 
  geom_point() +
  #facet_grid(name ~ prepost, space="free", scales="free", switch="y") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90)) #+ guides(color=FALSE) +
  #theme(axis.text.y = element_blank(),strip.placement = "outside", strip.background = element_rect(fill=NA, colour="grey50")) 

ggplot(countsPerRegion, aes(x=roi, y=type, size=partnersRatio, color=npartnerTypes)) + 
  geom_point() +
  #facet_grid(name ~ prepost, space="free", scales="free", switch="y") +
  theme_bw() + theme(axis.text.x = element_text(angle = 90)) #+ guides(color=FALSE) +
  #theme(axis.text.y = element_blank(),strip.placement = "outside", strip.background = element_rect(fill=NA, colour="grey50")) 
```

